Как создавать собственные функции и зачем они нужны
Вы уже познакомились с некоторыми встроенными функциями Python — например, print(), input(), max(), min() и другими.

Но часто в программе возникает необходимость повторно использовать один и тот же блок кода. Чтобы не писать его каждый раз заново, программисты выносят такую часть в отдельную функцию.

Функции позволяют:

переиспользовать один и тот же код без копирования;
сделать программу более читаемой и структурированной — за счёт разделения логики на небольшие, понятные блоки.
Синтаксис функции
Вот как выглядит базовое определение функции в Python:

def имя_функции(аргументы):
    тело функции
Что такое аргументы функции и как они передаются
Аргументы функции — это значения, которые передаются при её вызове и становятся переменными внутри тела функции.


Вступайте в сообщество хендбука
Здесь можно найти единомышленников, экспертов и просто интересных собеседников. А ещё — получить помощь или поделиться знаниями.
Тело функции выполняет операции с этими аргументами, а также, при необходимости, с внешними переменными. Когда функция завершает работу, она может вернуть результат с помощью оператора return. После этого интерпретатор продолжает выполнение основной программы, подставляя возвращённое значение на место вызова функции.

Рассмотрим пример: здесь создаётся функция, которая принимает список чисел и проверяет, все ли они чётные.

def only_even(numbers):
    result = True
    for x in numbers:
       if x % 2 != 0:
           result = False
            break
   return result

print(only_even([2, 4, 6]))
print(only_even([1, 2, 3]))

# Вывод программы:
# True
# False
Как работает оператор return и какие значения может возвращать функция
В функции можно использовать несколько операторов return. Как только срабатывает первый из них, выполнение функции немедленно прекращается, а результат передаётся в основную программу.

Пример: перепишем функцию only_even так, чтобы сразу возвращать результат без использования флага result:

def only_even(numbers):
    for x in numbers:
        if x % 2 != 0:
            return False
    return True

print(only_even([2, 4, 6]))
print(only_even([1, 2, 3]))

# Вывод программы:
# True
# False
Если в функции отсутствует return или он используется без значения, Python всё равно вернёт специальный объект None. Это тип, обозначающий отсутствие результата.

Пример:

print(print("Эту строку выведет функция до возврата значения."))

# Вывод программы:
# Эту строку выведет функция до возврата значения.
# None
Кроме того, функция может возвращать сразу несколько значений, указанных через запятую. Они автоматически объединяются в кортеж:

def only_even(numbers):
    for i, x in enumerate(numbers):
        if x % 2 != 0:
            return False, i
    return True

print(only_even([2, 4, 6]))
print(only_even([1, 2, 3]))

# Вывод программы:
# True
# (False, 0)
Обратите внимание: в первом случае функция возвращает значение логического типа (True), а во втором — кортеж ((False, 0)). Это важно учитывать при дальнейшем использовании результата: от типа возвращаемого значения зависит, какие операции с ним возможны.

Что такое область видимости. Чем различаются локальные и глобальные переменные
Аргументы функции становятся локальными переменными — это значит, что они доступны только внутри этой функции. Если попытаться обратиться к ним снаружи, произойдёт ошибка.

Рассмотрим пример:

def only_even(numbers):
    for i, x in enumerate(numbers):
        if x % 2 != 0:
            return False, i
    return True

print(numbers)

# Вывод программы:
# NameError: name 'numbers' is not defined
Ошибка возникла потому, что переменная numbers определена как аргумент функции и существует только в момент её выполнения. Такая переменная находится в локальной области видимости.

Существует и глобальная область видимости — она охватывает переменные, созданные вне функций, например в основном теле программы. К таким переменным можно обращаться из любой части программы, в том числе внутри функций.

Пример:

def check_password(pwd):
    return pwd == password

password = "Python"
print(check_password("123"))

# Вывод программы:
# False
В этом случае переменная password определена глобально и доступна внутри функции check_password.

Важно: хотя глобальные переменные доступны из функции, изменять их без специальных приёмов нельзя — об этом поговорим в следующем разделе.

Как безопасно изменять переменные, переданные в функцию
Можно ли изменить переменную из глобальной области видимости внутри функции? Ответ зависит от типа данных переменной:

Если это изменяемый тип (например, список), то изменение происходит напрямую.
Если это неизменяемый тип (например, число или строка), то попытка изменить значение создаёт локальную копию с тем же именем.
Рассмотрим пример с изменяемым типом — списком:

def list_modify():
    del sample[-1]

sample = [1, 2, 3]
list_modify()
print(sample)
# Вывод программы:
# [1, 2]
А теперь пример, где внутри функции происходит присваивание нового значения списку:

def list_modify():
    sample = [4, 5, 6]

sample = [1, 2, 3]
list_modify()
print(sample)

# Вывод программы:
# [1, 2, 3]
В этом случае внутри функции создаётся новая локальная переменная sample, и она никак не влияет на глобальную переменную с тем же именем.

То же самое касается аргументов функции. Они ведут себя как локальные переменные:

def list_modify_1(list_arg):
    # создаём новый локальный список, не имеющий связи с внешним
    list_arg = [1, 2, 3, 4]

def list_modify_2(list_arg):
    # меняем исходный внешний список, переданный как аргумент
    list_arg += [4]

sample_1 = [1, 2, 3]
sample_2 = [1, 2, 3]
list_modify_1(sample_1)
list_modify_2(sample_2)
print(sample_1)
print(sample_2)

# Вывод программы:
# [1, 2, 3]
# [1, 2, 3, 4]
Во втором случае список действительно изменился, потому что операция += модифицирует объект на месте.

Если вам всё же нужно изменить глобальную переменную внутри функции, это можно сделать с помощью ключевого слова global:

def inc():
    global x
    x += 1
    print(f"Количество вызовов функции равно {x}.")

x = 0
inc()
inc()
inc()

# Вывод программы:

# Количество вызовов функции равно 1.
# Количество вызовов функции равно 2.
# Количество вызовов функции равно 3.
Однако использовать global нужно с осторожностью. Глобальные переменные делают код менее предсказуемым: любое изменение может произойти в любой части программы, и это затрудняет отладку.

Обычно лучше передавать значения в функцию и возвращать результат, как показано ниже:

def f(count):
    count += 1
    print(f'Количество вызовов функции равно {count}.')
    return count

count_f = 0
count_f = f(count_f)
count_f = f(count_f)
count_f = f(count_f)

# Вывод программы:
# Количество вызовов функции равно 1.
# Количество вызовов функции равно 2.
# Количество вызовов функции равно 3.

Чем различаются позиционные и именованные аргументы
В прошлом параграфе вы познакомились с функциями. В них можно передавать параметры — они называются аргументами. На этом этапе вы уже умеете передавать аргументы, просто перечисляя их значения при вызове функции. Такой способ передачи называется позиционным: значения передаются строго в том порядке, в котором заданы параметры в определении функции.

Рассмотрим пример. Напишем функцию, которая считает окончательную стоимость товара с учётом скидки в процентах:

def final_price(price, discount):
    return price - price * discount / 100

print(final_price(1000, 5))

# Вывод программы:
# 950.0
Зачем нужны значения по умолчанию и какие ошибки могут возникнуть при их использовании
В Python можно задать значения по умолчанию для аргументов функции. Это особенно удобно, когда функция часто вызывается с одними и теми же параметрами, — можно не указывать их явно каждый раз.

В следующем примере аргумент discount по умолчанию равен 1 — то есть скидка будет 1%, если другое значение не указано.

def final_price(price, discount=1):
    return price - price * discount / 100


print(final_price(1000, 5))
# Значение скидки не задано, используется значение по умолчанию
print(final_price(1000))
Вывод программы:
950.0
990.
Обратите внимание: значение по умолчанию присваивается один раз — в момент объявления функции. Если значение — объект изменяемого типа (например, список), это может привести к неожиданному поведению.

Рассмотрим пример, в котором аргумент по умолчанию — список. Функция добавляет значение x в список и возвращает его:

def add_value(x, list_arg=[]):
    list_arg += [x]
    return list_arg

print(add_value(0))
print(add_value(0, [1, 2, 3]))
print(add_value(1))

Вступайте в сообщество хендбука
Здесь можно найти единомышленников, экспертов и просто интересных собеседников. А ещё — получить помощь или поделиться знаниями.
Вывод программы:
[0]
[1, 2, 3, 0]
[0, 1]
Что здесь произошло?

Первый вызов add_value(0) добавил значение в пустой список, созданный по умолчанию.
Второй вызов использует явно переданный список, поэтому работает ожидаемо.
А вот третий снова использует значение по умолчанию — но оно уже содержит элемент 0 от первого вызова.
Такой побочный эффект связан с тем, что список в значении по умолчанию сохраняется между вызовами функции. Чтобы избежать таких ошибок, принято использовать None и создавать новый список внутри функции:

def add_value(x, list_arg=None):
    if list_arg is None:
        list_arg = []
    list_arg += [x]
    return list_arg

print(add_value(0))
print(add_value(0, [1, 2, 3]))
print(add_value(1))
Вывод программы:
[0]
[1, 2, 3, 0]
[1]
Теперь каждый вызов работает независимо, и никакие старые значения не сохраняются.

Часто у функций много параметров, и порядок их передачи бывает трудно запомнить. Чтобы сделать вызов понятнее, Python позволяет передавать значения по имени аргумента, — такие аргументы называются именованными.

Посмотрим, как это работает, на примере функции final_price:

def final_price(price, discount=1):
    return price - price * discount / 100

print(final_price(1000, discount=5))
print(final_price(discount=10, price=1000))
Вывод программы:
950.0
900.0
Именованные аргументы позволяют не соблюдать порядок, указанный в определении функции, — если вы явно указываете имена. Это делает вызовы функций более читаемыми.

Обратите внимание: позиционные аргументы всегда должны идти первыми, а именованные — после них.

В итоге вы можете гибко комбинировать типы аргументов — тип зависит от того, как именно вы передаёте значение при вызове функции: просто перечисляете или явно указываете имя.

Как функция может принимать произвольное количество аргументов с помощью *args и **kwargs
Иногда заранее неизвестно, сколько аргументов нужно будет передать в функцию. В Python предусмотрена возможность принимать произвольное количество как позиционных, так и именованных аргументов.

Позиционные аргументы: *args
Если функция должна принимать любое количество позиционных аргументов, в её объявлении можно использовать звёздочку * перед именем параметра — чаще всего его называют args. Внутри функции такой параметр становится кортежем, содержащим все переданные значения.

Примером такой гибкой функции является print(), которая принимает сколько угодно аргументов.

Модифицируем знакомую нам функцию final_price(), чтобы она могла рассчитывать скидку сразу для нескольких цен:

def final_price(*prices, discount=1):
    return [price - price * discount / 100 for price in prices]

print(final_price(100, 200, 300, discount=5))
Вывод программы:
[95.0, 190.0, 285.0]
Функция получила три значения в *prices, применила скидку к каждому и вернула результат в виде списка.

Именованные аргументы: **kwargs
Если нужно принимать любое количество именованных аргументов, используется ** перед именем параметра — обычно kwargs (англ. keyword arguments). Такой параметр внутри функции представляет собой словарь, в котором:

ключи — это имена переданных аргументов;
значения — это их соответствующие значения.
Допустим, мы хотим добавить в функцию final_price() фильтр: рассчитывать скидку только для цен в определённом диапазоне. Границы диапазона (price_low и price_high) передаются как именованные аргументы через **kwargs.

def final_price(*prices, discount=1, **kwargs):
    low = kwargs.get("price_low", min(prices))
    high = kwargs.get("price_high", max(prices))
    return [price - price * discount / 100 for price in prices if low <= price <= high]

print(final_price(100, 200, 300, 400, 500, discount=5))
print(final_price(100, 200, 300, 400, 500, discount=5, price_low=200))
print(final_price(100, 200, 300, 400, 500, discount=5, price_high=200))
print(final_price(100, 200, 300, 400, 500, discount=5, price_low=200, price_high=350))
Вывод программы:

[95.0, 190.0, 285.0, 380.0, 475.0]
[190.0, 285.0, 380.0, 475.0]
[95.0, 190.0]
[190.0, 285.0]
Что здесь происходит:

Если price_low или price_high не переданы, берутся минимальное и максимальное значения из *prices.
Функция фильтрует цены по диапазону и рассчитывает скидку только для подходящих значений.
Что такое функции высших порядков и как передавать функции как аргументы
В Python функция может принимать другую функцию в качестве аргумента. Важно понимать, что в этом случае мы передаём не результат вызова функции, а ссылку на саму функцию — то есть указываем её имя без круглых скобок.

Функции, которые принимают другие функции как аргументы, называют функциями высшего порядка.

Функция filter()
Функция filter() позволяет отобрать элементы из итерируемого объекта по заданному критерию. В качестве критерия передаётся функция, возвращающая логическое значение (True или False). Результат filter() — это итератор, содержащий только те элементы, для которых функция-критерий вернула True.

Пример: отбираем из списка только положительные числа.

def only_pos(x):
    return x > 0

result = filter(only_pos, [-1, 5, 6, -10, 0])
print(", ".join(str(x) for x in result))
Вывод программы:

5, 6
Можно использовать не только пользовательские функции, но и встроенные методы Python, если они соответствуют условиям: принимают нужный тип данных и возвращают логическое значение.

Пример: отбираем из строки только буквы, используя метод str.isalpha().

result = filter(str.isalpha, "123ABcd()")
print("".join(result))
Вывод программы:

ABcd
Функция map()
Функция map() позволяет преобразовать каждый элемент итерируемого объекта с помощью заданной функции. Она возвращает итератор, в котором каждый элемент — результат применения функции-обработчика.

Пример: возводим в квадрат все числа из диапазона.

def square(x):
    return x ** 2

result = map(square, range(5))
print(", ".join(str(x) for x in result))
Вывод программы:

0, 1, 4, 9, 16
Как и в filter(), в map() можно передавать встроенные функции и методы.

Пример: преобразуем все строки в списке к нижнему регистру с помощью str.lower().

result = map(str.lower, ["abCD", "EFGh", "IJkl"])
print("\n".join(result))
Вывод программы:

abcd
efgh
ijkl
Типичный приём: преобразование ввода
Один из частых примеров использования map() — преобразование пользовательского ввода:

numbers = list(map(int, input().split()))
Эта строка кода:

считывает строку из ввода,
разбивает её по пробелам,
преобразует каждое значение в int,
собирает всё в список.
Как устроены лямбда-функции и когда их удобно применять в Python
Когда нужно передать небольшую функцию в качестве аргумента, например, в map() или filter(), не всегда удобно отдельно объявлять её с помощью def. В таких случаях в Python используют лямбда-функции — компактный способ описать функцию прямо внутри вызова другой функции.

Лямбда-функции — это безымянные функции, которые чаще всего используются один раз, «на месте».

Синтаксис
Объявление лямбда-функции выглядит так:

lambda x: x > 0
lambda — ключевое слово;
x — аргумент функции (может быть несколько);
после двоеточия — возвращаемое значение (без return).
Такая запись создаёт функцию, которая возвращает True, если x > 0.

Использование в filter() и map()
Перепишем предыдущие примеры, используя лямбда-функции вместо обычных:

result = filter(lambda x: x > 0, [-1, 5, 6, -10, 0])
print(", ".join(str(x) for x in result))
Вывод программы:

5, 6
А теперь применим lambda к другому случаю — например, возведению чисел в квадрат:

result = map(lambda x: x ** 2, range(5))
print(", ".join(str(x) for x in result))
Вывод программы:

0, 1, 4, 9, 16
Лямбда-функции особенно удобны, когда нужно передать простую логику, не создавая для неё отдельную именованную функцию.

Сортировка с помощью sorted() и лямбда-функции
Функции sorted(), sort(), min() и max() принимают именованный аргумент key — функцию, которая вычисляет ключ для сравнения элементов. Часто в роли такой функции удобно использовать лямбду.

Пример: сортировка строк по длине:

lines = ["abcd", "ab", "abc", "abcdef"]
print(sorted(lines, key=lambda line: len(line)))
Вывод программы:

['ab', 'abc', 'abcd', 'abcdef']
Сортировка по нескольким критериям
Можно возвращать из лямбда-функции кортеж — тогда сортировка будет учитывать несколько условий.
Пример: сначала по длине, потом по алфавиту:

lines = ["abcd", "ab", "ba", "acde"]
print(sorted(lines, key=lambda line: (len(line), line)))
Вывод программы:

['ab', 'ba', 'abcd', 'acde']
Пример: по убыванию длины, а при равенстве — по алфавиту:

lines = ["abcd", "ab", "ba", "acde"]
print(sorted(lines, key=lambda line: (-len(line), line)))
Вывод программы:

['abcd', 'acde', 'ab', 'ba']
Применение в min() и max()
Лямбда-функции можно использовать и в других встроенных функциях, например чтобы найти самую длинную строку (а при равной длине — лексикографически меньшую):

lines = ["abcd", "ab", "ba", "acde"]
print(min(lines, key=lambda line: (-len(line), line)))
Вывод программы:

abcd
Альтернатива: генераторные выражения
Часто то, что можно сделать с map() или filter(), проще выразить через генераторные выражения — они более наглядны и читаемы:

result = (x for x in [-1, 5, 6, -10, 0] if x > 0)
print(", ".join(str(x) for x in result))
Вывод программы:

5, 6
Что лучше использовать — map() / filter() или генераторные выражения? Это вопрос вкуса. Создатель Python Гвидо ван Россум предлагал отказаться от map() и filter() в пользу более читаемых генераторных выражений.

Лямбда-функции и reduce()
Ещё одна функция высшего порядка, где часто используют лямбда-функции, — это reduce() из модуля functools. Она кумулятивно (с накоплением) применяет заданную функцию к элементам итерируемого объекта и возвращает одно значение.

Другими словами, reduce() «сворачивает» последовательность в одно итоговое значение.

Пример: найдём сумму чисел от 1 до 5 с помощью reduce() и лямбда-функции:

from functools import reduce
numbers = range(1, 6)
print(reduce(lambda x, y: x + y, numbers))
Вывод программы:

15
Здесь reduce() последовательно складывает элементы:

 (((1 + 2) + 3) + 4) + 5 → 15.
Такой подход удобно использовать и для других операций — например, произведения, конкатенации строк, поиска минимума и т. д.

Что такое рекурсивные функции и как их правильно составлять
Рассмотрим классическую задачу — вычисление факториала числа. В математике факториал обозначается знаком ! и определяется так:

0
!
=
1.
0!=1.

n
!
=
1
∗
2
∗
.
.
.
∗
n
,
n
>
0.
n!=1∗2∗...∗n,n>0.

Сначала реализуем функцию, которая вычисляет факториал числа n с помощью цикла:

def fact(n):
    factorial = 1
    for i in range(2, n + 1):
        factorial *= i
    return factorial

print(fact(5))

# Вывод программы:
# 120
Теперь перепишем определение факториала немного по-другому:


Вступайте в сообщество хендбука
Здесь можно найти единомышленников, экспертов и просто интересных собеседников. А ещё — получить помощь или поделиться знаниями.
0
!
=
1.
0!=1.

n
!
=
(
1
∗
2
∗
.
.
.
∗
(
n
−
1
)
)
∗
n
=
(
n
−
1
)
!
∗
n
.
n!=(1∗2∗...∗(n−1))∗n=(n−1)!∗n.

Это значит, что, чтобы найти n!, мы можем сначала вычислить (n - 1)!, а потом умножить результат на n. Такой способ удобно реализовать с помощью рекурсии.

Рекурсивной называется функция, которая в процессе своей работы вызывает саму себя. Такие функции особенно полезны при работе с задачами, где решение строится на основе более простых подзадач того же типа.

Чтобы правильно составить рекурсивную функцию, нужно выполнить два шага:

Задать базовый случай — то, что функция должна вернуть при простейшем значении аргумента.
Задать рекурсивное правило — то, как вычислить результат на основе значения функции от меньшего аргумента.
Вот как будет выглядеть рекурсивная реализация вычисления факториала:

def fact(n):
    if n == 0:  # 0! = 1
        return 1
    return fact(n - 1) * n  # n! = (n - 1)! * n

print(fact(5))

# Вывод программы:
# 120
Чем отличаются императивный и декларативный стили программирования
Обратите внимание: рекурсивная версия функции факториала буквально повторяет математическое определение: n! = (n - 1)! × n.
В ней не описан пошаговый процесс вычислений, а задано само правило. Такой подход называется декларативным.

Декларативный стиль программирования описывает, что должно быть получено, а не как этого достичь.

Для сравнения, первая версия функции с циклом (for i in range...) относится к императивному стилю. В ней явно указано, как именно нужно последовательно выполнить действия, чтобы получить результат.

Императивный стиль фокусируется на процессе: он отвечает на вопрос «как это сделать?», тогда как декларативный — на «что именно нужно получить?».

Рекурсивные функции ближе к декларативному стилю: они делают код более выразительным и компактным. Однако, как вы увидите дальше, у такого подхода есть свои ограничения — особенно когда речь идёт о производительности.

Почему рекурсивные алгоритмы могут быть медленными — и как это исправить
Рассмотрим применение рекурсивной функции для вычисления n-го числа последовательности Фибоначчи. Это последовательность, в которой:

первые два числа равны 1;
каждое последующее — сумма двух предыдущих.
Иными словами:

fib(0) = 1
fib(1) = 1
fib(n) = fib(n - 1) + fib(n - 2), если n > 1
На языке Python рекурсивная функция для вычисления n-го числа Фибоначчи может выглядеть так:

def fib(n):
    if n in (0, 1):
        return 1
    return fib(n - 1) + fib(n - 2)

print(fib(35))

# Вывод программы:
# 14930352
Однако при запуске программы вы можете заметить, что вычисление происходит с ощутимой задержкой. Чтобы это измерить, воспользуемся модулем timeit, который позволяет узнать среднее время выполнения фрагмента кода:

from timeit import timeit

def fib(n):
    if n in (0, 1):
        return 1
    return fib(n - 1) + fib(n - 2)

print(f"Среднее время вычисления: "
     f"{round(timeit('fib(35)', number=10, globals=globals()) / 10, 3)} с.")

# Вывод программы:
# Среднее время вычисления: 2.924 с.
А теперь сравним с итеративной (императивной) версией той же функции:

from timeit import timeit

def fib(n):
    f_1, f = 1, 1
    for i in range(n - 1):
        f_1, f = f, f_1 + f
    return f

print(f"Среднее время вычисления: "
     f"{round(timeit('fib(35)', number=10, globals=globals()) / 10, 3)} с.")

# Вывод программы:
# Среднее время вычисления: 2e-06 с.
Разница огромная: две микросекунды против почти трёх секунд. Почему же рекурсивная функция настолько медленнее?

Причина в том, что при каждом вызове fib(n) функция вызывает саму себя дважды: один раз для fib(n - 1) и один раз для fib(n - 2). Это приводит к тому, что одни и те же значения пересчитываются много раз. Получается ветвящееся рекурсивное дерево, в котором одни и те же подзадачи повторяются снова и снова.

Python
Чтобы наглядно это увидеть, добавим счётчик вызовов функции:

def fib(n):
    global count
    count += 1
    if n in (0, 1):
        return 1
    return fib(n - 1) + fib(n - 2)

count = 0
print(f"35-е число Фибоначчи равно: {fib(35)}.")
print(f"Количество вызовов рекурсивной функции равно: {count}.")

# Вывод программы:
# 35-е число Фибоначчи равно: 14930352.
# Количество вызовов рекурсивной функции равно: 29860703.
Решение — запоминать уже вычисленные значения, чтобы не считать их повторно. Такой приём называется кешированием или мемоизацией.
Один из способов — сохранять промежуточные результаты в словаре:

def fib(n):
    global count
    count += 1
    if n not in cache:
        cache[n] = fib(n - 1) + fib(n - 2)
    return cache[n]

count = 0
cache = {0: 1, 1: 1}
print(f"35-е число Фибоначчи равно: {fib(35)}.")
print(f"Количество вызовов рекурсивной функции равно: {count}.")

# Вывод программы:
# 35-е число Фибоначчи равно: 14930352.
# Количество вызовов рекурсивной функции равно: 69.
Теперь попробуем измерить скорость:

from timeit import timeit

def fib(n):
    global count
    count += 1
    if n not in cache:
        cache[n] = fib(n - 1) + fib(n - 2)
    return cache[n]

count = 0
cache = {0: 1, 1: 1}
print(f"Среднее время вычисления: "
     f"{round(timeit('fib(35)', number=10, globals=globals()) / 10, 6)} с.")

# Вывод программы:
# Среднее время вычисления: 2e-06 с.
Функция работает почти так же быстро, как итеративная, — но при этом остаётся декларативной.

Попробуем теперь вычислить большее число, например fib(1000):

from timeit import timeit

def fib(n):
    if n not in cache:
        cache[n] = fib(n - 1) + fib(n - 2)
    return cache[n]

cache = {0: 1, 1: 1}
print(f"Среднее время вычисления: "
     f"{round(timeit('fib(1000)', number=10, globals=globals()) / 10, 6)} с.")
Программа завершится ошибкой:

RecursionError: maximum recursion depth exceeded
В Python по умолчанию глубина рекурсии ограничена (обычно до 1000). Чтобы увеличить лимит, используйте setrecursionlimit из модуля sys:

from timeit import timeit
from sys import setrecursionlimit

def fib(n):
    if n not in cache:
        cache[n] = fib(n - 1) + fib(n - 2)
    return cache[n]

setrecursionlimit(2000)
cache = {0: 1, 1: 1}
print(f"Среднее время вычисления: "
     f"{round(timeit('fib(1000)', number=10, globals=globals()) / 10, 6)} с.")

# Вывод программы:
# Среднее время вычисления: 0.000132 с.
Обратите внимание: максимально допустимая глубина рекурсии зависит от операционной системы. Увеличивать её можно, но не бесконечно.

Итак, мы ускорили работу рекурсивного алгоритма с помощью кеширования. Но при этом код стал менее читаемым — появились глобальные переменные и дополнительные проверки. Как сделать то же самое, но проще? В следующем разделе вы узнаете, как поручить кеширование интерпретатору Python с помощью встроенного инструмента — декоратора.

Как работает кеширование с помощью lru_cache
Чтобы не писать дополнительный код вручную, можно поручить кеширование самому интерпретатору. В стандартной библиотеке Python для этого предусмотрен удобный инструмент — декоратор lru_cache из модуля functools.

Он позволяет автоматически запоминать результаты предыдущих вызовов функции и использовать их повторно. Это особенно полезно для рекурсивных функций, где часто повторяются одни и те же вычисления с одинаковыми аргументами.

Вот пример использования:

from timeit import timeit
from functools import lru_cache

@lru_cache(maxsize=1000)
def fib(n):
    if n in (0, 1):
        return 1
    return fib(n - 1) + fib(n - 2)

print(f"Среднее время вычисления: "
     f"{round(timeit('fib(35)', number=10, globals=globals()) / 10, 6)} с.")

# Вывод программы:
# Среднее время вычисления: 2e-06 с.
Как видите, результат сопоставим с кешированием через словарь — но при этом код стал намного чище и короче.

Благодаря @lru_cache функция вновь принимает декларативную форму: она просто описывает правило вычисления, а управление памятью и ускорение берёт на себя интерпретатор.

Если вы хотите сбросить кеш или узнать, сколько значений в нём хранится, у lru_cache есть методы .cache_clear() и .cache_info(). Подробнее о них — в документации.

Что такое декораторы и как они помогают расширять поведение функций
Иногда нужно изменить поведение функции — например, добавить логирование, измерение времени выполнения или кеширование результатов. Но менять сам код функции при этом не хочется (или нельзя). В таких случаях удобно использовать декораторы.

Декоратор — это специальная конструкция, которая оборачивает функцию и может изменить её поведение до, после или вместо обычного вызова.

В Python уже есть готовые декораторы. Один из них — lru_cache из модуля functools. Он автоматически сохраняет (кеширует) результаты вызова функции, чтобы при повторном вызове с теми же аргументами не пересчитывать результат заново.

Рассмотрим базовый пример:

def func():
    ...

def decorator(old_func):
    def new_func():
        return old_func()

    return new_func

print(func)
func = decorator(func)
print(func)
Если вы выполните этот код, то увидите, что func превратилась в другую функцию — new_func, обёрнутую в дополнительную логику.

Чтобы не вызывать декоратор вручную, Python предлагает синтаксический сахар — специальную конструкцию с символом @. С её помощью пример выше можно записать так:

def decorator(old_func):
    def new_func():
        return old_func()

    return new_func

@decorator
def func():
    ...
Теперь напишем декоратор, который будет считать, сколько раз была вызвана функция, и возвращать это количество вместе с результатом. Такой приём может пригодиться, если вы хотите отладить код или проанализировать его поведение:

# Декоратор принимает функцию f как аргумент
def count(f):
    total = 0

    # Объявляем функцию, которая расширяет функционал f
    def decorated(*args, **kwargs):
        # Переменная total объявлена нелокальной для доступа из внутренней функции
        nonlocal total
        total += 1
       # Возвращаем значение исходной функции и дополнительно total
       return f(*args, **kwargs), total
   # Возвращаем новую функцию как объект
   return decorated
Теперь применим этот декоратор к простой функции hello, которая приветствует пользователя по имени:

@count
def hello(name):
    return f"Привет, {name}!"

print(hello("Пользователь_1"))
print(hello("Пользователь_2"))
Что здесь важно:

Мы используем ключевое слово nonlocal, чтобы переменная total сохраняла своё значение между вызовами.
Аргументы *args и **kwargs позволяют оборачивать любую функцию — с любым числом позиционных и именованных параметров.
Декоратор возвращает новую функцию, которая сначала выполняет дополнительную логику, а затем вызывает оригинальную.
Таким образом, декораторы позволяют расширять поведение функций, не трогая их определение. Это мощный инструмент, особенно когда нужен переиспользуемый и чистый код.

Что такое генераторы и чем они полезны при работе с большими объёмами данных
В Python функции могут возвращать не только готовое значение, но и генератор — специальный объект, который выдаёт элементы по одному, по запросу. Это особенно удобно, когда вы работаете с большим количеством данных и нет смысла загружать всё в память сразу.

С генераторами вы уже сталкивались, даже если не замечали этого. Например, в выражениях вроде:

squares = (i ** 2 for i in range(10))
print(squares)

# Вывод программы:
# <generator object <genexpr> at 0x000001C225EFC9E0>
Такой объект не содержит все значения сразу — он выдаёт их по одному при каждой итерации. Чтобы получить значение, вызывается метод __next__() (обычно неявно — например, в цикле for).

Чтобы написать свою собственную функцию-генератор, вместо оператора return нужно использовать yield. Этот оператор:

приостанавливает выполнение функции;
возвращает текущее значение;
позволяет продолжить выполнение с того места, где функция остановилась.
Рассмотрим генераторную версию функции Фибоначчи:

def fib(n):
    n_1, n_2 = 1, 1
    for i in range(n):
        yield n_1
        n_1, n_2 = n_2, n_1 + n_2


print(", ".join(str(x) for x in fib(10)))

# Вывод программы:
# 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
Обратите внимание: внутри функции fib() есть цикл на n итераций, но выполняются они не все сразу. Генератор работает лениво — значения вычисляются и выдаются только по мере запроса. Если вы в цикле прерываете выполнение, недостающие значения так и не будут вычислены.
Это особенно важно при работе с большими или бесконечными последовательностями — генераторы экономят память и ускоряют работу.

Также учтите, что в одной функции-генераторе можно использовать несколько операторов yield, как в обычной функции допускается несколько return.

Кроме того, генераторы отлично сочетаются с циклами, выражениями-генераторами и конструкциями вроде map() или filter().