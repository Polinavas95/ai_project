Иногда программе нужно многократно выполнять одно и то же действие. Например, запрашивать пароль у пользователя до тех пор, пока он не введёт правильный.

Важно: это учебный пример. В реальных системах пароли шифруются и проверяются вместе с логином.

Если использовать только условные операторы, программа сможет проверить пароль только один раз.Чтобы повторять проверку столько раз, сколько нужно, используется цикл — он позволяет выполнять код многократно.

saved_pwd = "right_password"
pwd = input("Введите пароль для входа: ")
while pwd != saved_pwd:
    pwd = input("Введите пароль для входа: ")
print("Пароль верный. Вход разрешён.")
Как видите, тут мы использовали цикл while. Давайте разберёмся, как он работает.

Цикл while
Цикл while выполняет код до тех пор, пока условие остаётся истинным (True). Как только условие перестаёт выполняться (False), цикл завершает работу, и программа продолжает выполнение со следующей строки.

Вспомните: в предыдущем параграфе мы разбирали, что результат проверки условий в Python — это логические значения True (истина) или False (ложь). Циклы работают по тем же правилам.

Важно: чтобы избежать бесконечного выполнения, у цикла должно быть условие, которое со временем становится ложным.

Как правильно оформлять циклы в коде?

Тело цикла (код, который нужно повторять) записывается с отступом в четыре пробела. В Python это обязательное требование: отступы показывают структуру программы.
Использовать табуляцию (Tab) вместо пробелов не рекомендуется — это может вызвать ошибки при выполнении.

Вступайте в сообщество хендбука
Здесь можно найти единомышленников, экспертов и просто интересных собеседников. А ещё — получить помощь или поделиться знаниями.
Каждый проход по телу цикла называется итерацией.
На каждой итерации Python заново проверяет условие:

Если условие истинно (True), выполняется очередной шаг цикла.
Если ложно (False), выполнение переходит к коду после цикла.
В предыдущем примере мы можем вообще обойтись без переменной pwd, так как она используется только в проверке условия продолжения цикла:

saved_pwd = "right_password"
while input("Введите пароль для входа: ") != saved_pwd:
    pass
print("Пароль верный. Вход разрешён.")
Что происходит в программе:

Пользователь вводит пароль.
Если пароль неправильный, снова появляется приглашение ко вводу.
Как только введён верный пароль, цикл завершается и выполняется следующий код.
Обратите внимание, что внутри тела цикла была использована пустая инструкция pass, которая делает ничего. Она нужна для того, чтобы код оставался синтаксически правильным. В Python нельзя оставить тело цикла пустым — это вызовет ошибку.

Поэтому, если действий выполнять не нужно, вставляется pass как заглушка.

Дальше мы рассмотрим, как сделать цикл ещё компактнее с помощью моржового оператора (:=).

Моржовый оператор (:=) в циклах
С версии Python 3.8 в языке появился моржовый оператор (:=), или walrus operator.

Он позволяет одновременно:

присвоить значение переменной,
использовать это значение в условии цикла.
Благодаря моржовому оператору код становится компактнее: не нужно отдельно запрашивать данные до начала цикла и внутри тела цикла.

Давайте напишем программу, которая будет здороваться со всеми людьми, чьи имена введёт пользователь. Сигнал для остановки — ввод строки «СТОП»:

name = input("Введите имя: ")
while name != "СТОП":
    print(f"Привет, {name}!")
    name = input("Введите имя: ")
print("Программа завершена.")
Как работает программа:

Сначала пользователь вводит имя.
Если введено не «СТОП», программа печатает приветствие и снова запрашивает имя.
Если введено «СТОП», цикл заканчивается.
А теперь перепишем программу выше с использования оператора :=.

while (name := input("Введите имя: ")) != "СТОП":
    print(f"Привет, {name}!")
print("Программа завершена.")
Что изменилось:

Теперь имя запрашивается сразу в условии цикла, а не отдельно до начала цикла и внутри тела цикла.
Благодаря моржовому оператору из программы были убраны строки, в которых имя считывалось дважды: один раз перед циклом и ещё один раз в теле цикла.
Теперь имя считывается один раз — прямо во время проверки условия.
Итак, цикл while удобно использовать тогда, когда заранее не известно, сколько раз нужно повторять действие, — мы просто проверяем условие на каждой итерации.

Но иногда мы заранее знаем, сколько раз должно выполниться действие. В таких случаях проще и удобнее использовать другой тип цикла — цикл for. Давайте посмотрим, как он устроен.

Цикл for
Цикл for используется, когда количество итераций заранее известно. Он выполняет код для каждого элемента заданной последовательности.

Обычно в цикле for используется итерируемая переменная. Чаще всего её называют i, но можно использовать любое осмысленное имя. На каждой итерации переменная принимает новое значение из диапазона.

Чтобы задать диапазон значений, в Python используется функция range().

Строго говоря, range() — это не функция, а встроенный тип данных (Built-in Type), который создаёт последовательность целых чисел. Подробнее про него можно почитать в документации.

Но для простоты мы будем называть его функцией.

Как работает range()
Функция range() может принимать от одного до трёх аргументов:

range(n) — создаёт последовательность от 0 до n - 1.
Пример:
range(4) → 0, 1, 2, 3

range(k, n) — создаёт последовательность от k до n - 1.
Пример:
range(1, 5) → 1, 2, 3, 4

range(k, n, s) — создаёт последовательность от k до n - 1 с шагом s.
Пример:
range(1, 10, 2) → 1, 3, 5, 7, 9

Примеры использования цикла for
В примерах ниже числа мы будем получать от пользователей, с помощью функции input().

Пример №1: выведем на экран n целых чисел, начиная с 0

n = int(input("Введите количество чисел: "))
for i in range(n):
    print(i)
Результат работы программы:

Введите количество чисел: 5
0
1
2
3
4
Пример №2: выведем на экран целые числа в диапазоне от k до n - 1

k = int(input("Введите начало диапазона: "))
n = int(input("Введите конец (без включения) диапазона: "))
for i in range(k, n):
    print(i)
Результат работы программы:

Введите начало диапазона: 2
Введите конец (без включения) диапазона: 5
2
3
4
Пример №3: выведем на экран целые чётные числа в диапазоне от 0 до n

n = int(input("Введите конец диапазона: "))
for i in range(0, n + 1, 2):
    print(i)
Результат работы программы:

Введите конец диапазона: 5
0
2
4
Пример №4: запустим цикл в обратном порядке

С помощью отрицательного шага можно перебирать числа от большего к меньшему:

n = int(input("Введите первое число: "))
for i in range(n, -1, -1):
    print(i)
Результат работы программы:

Введите первое число: 5
5
4
3
2
1
0
Пример №5: что происходит, если диапазон пустой

Попробуем указать параметры диапазона, в который не попадёт ни одно число. Например, range(1, 5, -1) или range(10, 1, 2).

Как можно видеть, ошибка не произойдёт, а функция range() просто вернёт пустую последовательность чисел. Если попытаться пройти в цикле по такой пустой последовательности, то не будет выполнено ни одной итерации:

for i in range(1, 5, -1):
    print(i)
Обратите внимание: изменение значения итерируемой переменной внутри тела цикла не имеет смысла, так как будет перезаписано на следующей итерации очередным значением из диапазона функции range().

Например, следующий код по-прежнему выведет числа от 0 до n - 1, несмотря на изменение значения итерируемой переменной в теле цикла:

n = int(input("Введите n: "))
for i in range(n):
    print(i)
    i = 100
Результат работы программы:

Введите n: 5
0
1
2
3
4
