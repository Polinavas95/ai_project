Что такое класс и объект в Python и как они связаны между собой
Предлагаем начать не с теории, а с практики. Напишем программу, которая будет моделировать объекты класса «Автомобиль». При этом важно заранее определить, какие свойства и действия должны быть у этих объектов.

Пусть каждый автомобиль имеет собственный цвет. Его двигатель можно запустить, если в баке есть топливо, и заглушить в любой момент. Автомобиль должен проезжать определённое расстояние — но только при условии, что двигатель включён, а топлива хватает на заданный путь. После каждой поездки запас топлива уменьшается. Также автомобиль можно заправить до полного бака.

Выделим ключевые характеристики объектов: цвет, средний расход топлива, объём бака, запас топлива, пробег. А также — действия: запуск и остановка двигателя, поездка, заправка.

На текущем этапе мы можем описать такой объект с помощью словаря и управлять им через отдельные функции. Ниже — пример реализации:

def create_car(color, consumption, tank_volume, mileage=0):
    return {
        "color": color,
        "consumption": consumption,
        "tank_volume": tank_volume,
        "reserve": tank_volume,
        "mileage": mileage,
        "engine_on": False
    }

def start_engine(car):
   if not car["engine_on"] and car["reserve"] > 0:
       car["engine_on"] = True
       return "Двигатель запущен."
   return "Двигатель уже был запущен."

def stop_engine(car):
   if car["engine_on"]:
       car["engine_on"] = False
       return "Двигатель остановлен."
   return "Двигатель уже был остановлен."

def drive(car, distance):
   if not car["engine_on"]:
       return "Двигатель не запущен."
   if car["reserve"] / car["consumption"] * 100 < distance:
       return "Малый запас топлива."
   car["mileage"] += distance
   car["reserve"] -= distance / 100 * car["consumption"]
   return f"Проехали {distance} км. Остаток топлива: {car['reserve']} л."

def refuel(car):
   car["reserve"] = car["tank_volume"]

def get_mileage(car):
   return f"Пробег {car['mileage']} км."

def get_reserve(car):
   return f"Запас топлива {car['reserve']} л."

car_1 = create_car(color="black", consumption=10, tank_volume=55)

print(start_engine(car_1))
print(drive(car_1, 100))
print(drive(car_1, 100))
print(drive(car_1, 100))
print(drive(car_1, 300))
print(get_mileage(car_1))
print(get_reserve(car_1))
print(stop_engine(car_1))
print(drive(car_1, 100))
Результат работы программы может выглядеть так:


Вступайте в сообщество хендбука
Здесь можно найти единомышленников, экспертов и просто интересных собеседников. А ещё — получить помощь или поделиться знаниями.
Двигатель запущен.
Проехали 100 км. Остаток топлива: 45.0 л.
Проехали 100 км. Остаток топлива: 35.0 л.
Проехали 100 км. Остаток топлива: 25.0 л.
Малый запас топлива.
Пробег 300 км.
Запас топлива 25.0 л.
Двигатель остановлен.
Двигатель не запущен.
В этом примере все действия над объектом реализованы через отдельные функции, которые получают словарь с данными. Такой стиль называется процедурным программированием. Он был основным в ранней истории языков программирования и до сих пор подходит для простых задач.

Однако с ростом сложности проекта этот подход становится громоздким. Код начинает дублироваться, логика — расползаться по множеству функций, а структура программы — усложняться и становиться уязвимой к ошибкам.

Чтобы решить эти проблемы, в Python используют объектно-ориентированное программирование (ООП). Этот подход позволяет объединять данные и связанные с ними действия в единую структуру — класс.

Класс — это шаблон (или описание), по которому создаются объекты. В классе задаются свойства (атрибуты) и действия (методы), общие для всех объектов этого типа.

Объект — это конкретный экземпляр класса, обладающий собственными значениями атрибутов. Объект знает, к какому классу он принадлежит, и может выполнять описанные в нём действия.

Python построен на объектной модели. Это значит, что практически всё в нём — объекты, созданные на основе классов. Например, число 1 — не просто значение, а объект встроенного класса int. Убедимся в этом:

print(type(1))

# Вывод программы:
# <class 'int'>
Всё в Python — объекты: числа, строки, функции, списки и даже модули. А самое важное — вы можете создавать свои собственные классы для описания любых сущностей, от автомобилей до пользователей и заказов.

Дальше мы увидим, как именно создаются классы и как они позволяют сделать код более чистым, гибким и надёжным.

Как задать свойства и поведение объектов с помощью атрибутов и методов
Создание собственных классов — основа объектно-ориентированного программирования. С их помощью можно задать как структуру объекта (его свойства), так и поведение (набор доступных действий).

Синтаксис определения класса в Python выглядит так:

class <ИмяКласса>:
    <описание класса>
Согласно стандарту оформления PEP 8, имя класса записывается в стиле CapWords — каждое слово начинается с заглавной буквы и не содержит подчёркиваний.

Например: Car, ElectricVehicle, UserProfile.

Давайте перепишем наш пример с автомобилем, используя классы. Начнём с самого простого — создадим пустой класс Car, в котором пока ничего не будет происходить. В этом случае используется инструкция-заглушка pass:

class Car:
    pass
Теперь разберёмся, как задать свойства и поведение объектов, создаваемых на основе этого класса.

Атрибуты — свойства объекта
Атрибутами называются переменные, которые хранятся внутри объекта. Они описывают состояние конкретного экземпляра класса — например, цвет, пробег, запас топлива и т. д.

Атрибут можно создать вручную после создания объекта:

<имя_объекта>.<имя_атрибута> = <значение>
Пример:

car.color = "чёрный"
Методы: как описать действия объекта
Методы — это функции, определённые внутри класса. Они описывают поведение объекта, например запуск двигателя, поездку или заправку.
Метод объявляется с помощью ключевого слова def, а первым его параметром всегда идёт self. Это ссылка на конкретный объект, для которого вызывается метод:

def start_engine(self):
    ...
С помощью self метод может обращаться к атрибутам и другим методам того же объекта. Без self объект не сможет «узнать» собственные свойства.

Как работает метод init()
Во всех классах Python можно определить специальный метод __init__(). Он автоматически вызывается при создании нового объекта и отвечает за начальную инициализацию его атрибутов.
Вернёмся к примеру с автомобилем и добавим метод __init__() в класс Car, чтобы задать значения свойств при создании:

class Car:

    def __init__(self, color, consumption, tank_volume, mileage=0):
        self.color = color
        self.consumption = consumption
        self.tank_volume = tank_volume
        self.reserve = tank_volume
        self.mileage = mileage
        self.engine_on = False
Здесь мы определили, что каждый объект класса Car будет обладать следующими атрибутами: цветом (color), средним расходом топлива (consumption), объёмом бака (tank_volume), текущим запасом топлива (reserve), пробегом (mileage) и состоянием двигателя (engine_on). Значения этих атрибутов задаются при создании объекта.

Для создания объекта на основе класса используют следующую запись:

<имя_объекта> = <ИмяКласса>(<аргументы метода __init__()>)
Пример:

car_1 = Car(color="black", consumption=10, tank_volume=55)
Обратите внимание: теперь всё, что относится к автомобилю, собрано внутри одного объекта. Такой подход делает код не только короче, но и понятнее, масштабируемее и легче в поддержке.

Что такое инкапсуляция и как она помогает защитить внутреннее состояние объекта
Теперь, когда мы описали свойства и поведение класса, наш код стало легче читать. Мы видим, что создаётся объект определённого типа (Car), а не просто передаётся словарь в набор функций. Вся логика работы с автомобилем теперь сосредоточена внутри самого класса.
Опишем с помощью методов, какие действия может выполнять объект Car. Напомним, что, согласно PEP 8, между методами класса нужно оставлять по одной пустой строке:

class Car:

    def __init__(self, color, consumption, tank_volume, mileage=0):
        self.color = color
        self.consumption = consumption
        self.tank_volume = tank_volume
        self.reserve = tank_volume
        self.mileage = mileage
        self.engine_on = False

    def start_engine(self):
        if not self.engine_on and self.reserve > 0:
            self.engine_on = True
            return "Двигатель запущен."
        return "Двигатель уже был запущен."

    def stop_engine(self):
        if self.engine_on:
            self.engine_on = False
            return "Двигатель остановлен."
        return "Двигатель уже был остановлен."

    def drive(self, distance):
        if not self.engine_on:
            return "Двигатель не запущен."
        if self.reserve / self.consumption * 100 < distance:
            return "Малый запас топлива."
        self.mileage += distance
        self.reserve -= distance / 100 * self.consumption
        return f"Проехали {distance} км. Остаток топлива: {self.reserve} л."

    def refuel(self):
        self.reserve = self.tank_volume

    def get_mileage(self):
        return self.mileage

    def get_reserve(self):
        return self.reserve


car_1 = Car(color="black", consumption=10, tank_volume=55)
print(car_1.start_engine())
print(car_1.drive(100))
print(car_1.drive(100))
print(car_1.drive(100))
print(car_1.drive(300))
print(f"Пробег {car_1.get_mileage()} км.")
print(f"Запас топлива {car_1.get_reserve()} л.")
print(car_1.stop_engine())
print(car_1.drive(100))
Вывод программы:

Двигатель запущен.
Проехали 100 км. Остаток топлива: 45.0 л.
Проехали 100 км. Остаток топлива: 35.0 л.
Проехали 100 км. Остаток топлива: 25.0 л.
Малый запас топлива.
Пробег 300 км.
Запас топлива 25.0 л.
Двигатель остановлен.
Двигатель не запущен.
Обратите внимание: все действия с объектом происходят через методы. Мы не изменяем значения атрибутов напрямую, а работаем с объектом через предусмотренный «интерфейс» — это и есть принцип инкапсуляции.

Инкапсуляция означает, что внутреннее состояние объекта скрыто от внешнего кода и доступно только через методы. Такой подход помогает:

избежать случайных ошибок при прямом изменении данных;
сохранить корректность логики внутри класса;
упростить отладку и поддержку программы.
Посмотрим, что произойдёт, если проигнорировать этот принцип и напрямую изменить атрибут mileage, не выполняя никаких проверок:

car_1 = Car(color="black", consumption=10, tank_volume=55)
car_1.mileage = 1000
print(f"Пробег {car_1.get_mileage()} км.")
print(f"Запас топлива {car_1.get_reserve()} л.")

# Вывод программы:
# Пробег 1000 км.
# Запас топлива 55 л.
Как видите, объект «проехал» 1000 км, хотя двигатель не запускался и топливо не расходовалось. Это делает данные недостоверными и нарушает логику работы модели. Именно от таких ситуаций инкапсуляция и защищает.

Позже мы узнаем, как ещё сильнее ограничивать доступ к данным с помощью специальных соглашений и модификаторов доступа.

Как реализовать полиморфизм в Python и в чём суть подхода «утиная типизация»
В предыдущем примере мы описали класс Car. Теперь давайте создадим ещё один класс — для электромобилей. Он будет отличаться от бензинового аналога тем, что вместо топливного бака у него есть аккумуляторная батарея:

class ElectricCar:

    def __init__(self, color, consumption, bat_capacity, mileage=0):
        self.color = color
        self.consumption = consumption
        self.bat_capacity = bat_capacity
        self.reserve = bat_capacity
        self.mileage = mileage
        self.engine_on = False

    def start_engine(self):
        if not self.engine_on and self.reserve > 0:
            self.engine_on = True
            return "Двигатель запущен."
        return "Двигатель уже был запущен."

    def stop_engine(self):
        if self.engine_on:
            self.engine_on = False
            return "Двигатель остановлен."
        return "Двигатель уже был остановлен."

    def drive(self, distance):
        if not self.engine_on:
            return "Двигатель не запущен."
        if self.reserve / self.consumption * 100 < distance:
            return "Малый заряд батареи."
        self.mileage += distance
        self.reserve -= distance / 100 * self.consumption
        return f"Проехали {distance} км. Остаток заряда: {self.reserve} кВт*ч."

    def recharge(self):
        self.reserve = self.bat_capacity

    def get_mileage(self):
        return self.mileage

    def get_reserve(self):
        return self.reserve
Допустим, мы хотим написать функцию range_reserve(), которая рассчитывает запас хода автомобиля. Она должна одинаково работать и с Car, и с ElectricCar. Такое поведение называется полиморфизмом — когда один и тот же интерфейс (в нашем случае — функция) работает с объектами разных типов.

Чтобы это было возможно, в обоих классах должны быть методы с одинаковыми именами и сигнатурами. Для расчёта запаса хода нам понадобится ещё один метод — get_consumption():

def range_reserve(car):
    return car.get_reserve() / car.get_consumption() * 100
При этом Python не требует, чтобы оба объекта были наследниками одного и того же класса. Важно лишь, чтобы объект поддерживал нужные методы, — именно это поведение называется утиная типизация.

Это поведение получило своё название от шутливого выражения:

«Если что-то выглядит как утка, плавает как утка и крякает как утка — значит, это утка»

Применительно к Python это значит: если объект умеет делать всё, что от него ожидается, мы можем с ним работать — даже не проверяя его тип с помощью isinstance.

Вот полная программа с двумя классами и функцией range_reserve():

class Car:

    def __init__(self, color, consumption, tank_volume, mileage=0):
        self.color = color
        self.consumption = consumption
        self.tank_volume = tank_volume
        self.reserve = tank_volume
        self.mileage = mileage
        self.engine_on = False

    def start_engine(self):
        if not self.engine_on and self.reserve > 0:
            self.engine_on = True
            return "Двигатель запущен."
        return "Двигатель уже был запущен."

    def stop_engine(self):
        if self.engine_on:
            self.engine_on = False
            return "Двигатель остановлен."
        return "Двигатель уже был остановлен."

    def drive(self, distance):
        if not self.engine_on:
            return "Двигатель не запущен."
        if self.reserve / self.consumption * 100 < distance:
            return "Малый запас топлива."
        self.mileage += distance
        self.reserve -= distance / 100 * self.consumption
        return f"Проехали {distance} км. Остаток топлива: {self.reserve} л."

    def refuel(self):
        self.reserve = self.tank_volume

    def get_mileage(self):
        return self.mileage

    def get_reserve(self):
        return self.reserve

    def get_consumption(self):
        return self.consumption


class ElectricCar:

    def __init__(self, color, consumption, bat_capacity, mileage=0):
        self.color = color
        self.consumption = consumption
        self.bat_capacity = bat_capacity
        self.reserve = bat_capacity
        self.mileage = mileage
        self.engine_on = False

    def start_engine(self):
        if not self.engine_on and self.reserve > 0:
            self.engine_on = True
            return "Двигатель запущен."
        return "Двигатель уже был запущен."

    def stop_engine(self):
        if self.engine_on:
            self.engine_on = False
            return "Двигатель остановлен."
        return "Двигатель уже был остановлен."

    def drive(self, distance):
        if not self.engine_on:
            return "Двигатель не запущен."
        if self.reserve / self.consumption * 100 < distance:
            return "Малый заряд батареи."
        self.mileage += distance
        self.reserve -= distance / 100 * self.consumption
        return f"Проехали {distance} км. Остаток заряда: {self.reserve} кВт*ч."

    def recharge(self):
        self.reserve = self.bat_capacity

    def get_mileage(self):
        return self.mileage

    def get_reserve(self):
        return self.reserve

    def get_consumption(self):
        return self.consumption


def range_reserve(car):
    return car.get_reserve() / car.get_consumption() * 100


car_1 = Car(color="black", consumption=10, tank_volume=55)
car_2 = ElectricCar(color="white", consumption=15, bat_capacity=90)
print(f"Запас хода: {range_reserve(car_1)} км.")
print(f"Запас хода: {range_reserve(car_2)} км.")
Вывод программы будет таким:

Запас хода: 550.0 км.
Запас хода: 600.0 км.
Благодаря тому, что у классов одинаковый интерфейс, мы легко применили одну и ту же функцию к объектам разной природы — без единой строчки лишней логики. Это и есть сила полиморфизма и утиных типов.

Что такое наследование в ООП и зачем оно нужно
В предыдущем параграфе вы узнали, как создавать собственные классы и описывать поведение объектов. Однако при работе с несколькими похожими классами быстро возникает повторение кода. Например, если у разных классов схожие атрибуты или действия, приходится копировать одни и те же методы.

Чтобы избежать дублирования, в объектно-ориентированном программировании применяется наследование.

Наследование позволяет создавать новый класс на основе уже существующего. Такой новый класс называется производным, или классом-наследником, а исходный класс — базовым. Производный класс унаследует все атрибуты и методы базового класса, но при этом может добавлять свои или изменять существующие.

Рассмотрим пример. Создадим базовый класс Pencil (карандаш), который хранит цвет и умеет рисовать. Затем на его основе создадим производный класс Pen (ручка). Ручка, как и карандаш, может рисовать, но вдобавок — подписывать документы (если цвет соответствует официальным требованиям):

class Pencil:

    def __init__(self, color="серый"):
        self.color = color

    def draw_picture(self):
        return f"Нарисован рисунок цветом '{self.color}'."

class Pen(Pencil):

    def sign_document(self):
        if self.color not in ("синий", "чёрный", "фиолетовый"):
            return f"Ручкой цвета '{self.color}' нельзя подписать документ."
        return f"Подписан документ."

blue_pen = Pen(color="синий")
print(blue_pen.draw_picture())
print(blue_pen.sign_document())
red_pen = Pen(color="красный")
print(red_pen.draw_picture())
print(red_pen.sign_document())

Вступайте в сообщество хендбука
Здесь можно найти единомышленников, экспертов и просто интересных собеседников. А ещё — получить помощь или поделиться знаниями.
Вывод программы:

Нарисован рисунок цветом 'синий'.
Подписан документ.
Нарисован рисунок цветом 'красный'.
Ручкой цвета 'красный' нельзя подписать документ.
В этом примере класс Pen унаследовал все свойства класса Pencil — инициализацию атрибута color и метод draw_picture. Мы не писали их заново — они просто перешли от базового класса к производному. Мы лишь добавили новый метод sign_document, специфичный для ручки.

Когда интерпретатор Python вызывает метод у объекта, он сначала ищет его в самом классе. Если метод не найден, поиск продолжается в базовом классе. Если нужно — ещё на уровень выше. Если ни в одном из родительских классов метод не обнаружен, будет вызвано исключение AttributeError.

Таким образом, наследование — мощный механизм, позволяющий переиспользовать код, сокращать дублирование и строить иерархии классов, в которых общее поведение определено один раз, а различия добавляются по мере необходимости.

Как работает множественное наследование и в чём его особенности в Python
В Python один класс может наследоваться сразу от нескольких базовых классов. Это называется множественным наследованием. В этом случае производный класс получает доступ ко всем атрибутам и методам всех родительских классов.

Рассмотрим пример с приветствием. Напишем три класса:

GreetingFormal — при инициализации создаёт атрибут formal_greeting со значением "Добрый день,"; метод greet_formal() возвращает приветствие по имени.
GreetingInformal — при инициализации создаёт атрибут informal_greeting со значением "Привет,"; метод greet_informal() также возвращает приветствие.
GreetingMix — наследуется сразу от двух предыдущих и умеет приветствовать как формально, так и неформально.
Чтобы задать множественное наследование, нужно перечислить базовые классы через запятую в определении производного:

class GreetingFormal:

    def __init__(self):
        self.formal_greeting = "Добрый день,"

    def greet_formal(self, name):
        return f"{self.formal_greeting} {name}!"

class GreetingInformal:

    def __init__(self):
        self.informal_greeting = "Привет,"

    def greet_informal(self, name):
        return f"{self.informal_greeting} {name}!"

class GreetingMix(GreetingFormal, GreetingInformal):

    def __init__(self):
        GreetingFormal.__init__(self)
        GreetingInformal.__init__(self)

mixed_greeting = GreetingMix()
print(mixed_greeting.greet_formal("Пользователь"))
print(mixed_greeting.greet_informal("Пользователь"))
Вывод программы:

Добрый день, Пользователь!
Привет, Пользователь!
Класс GreetingMix унаследовал методы обоих классов. Чтобы корректно проинициализировать все атрибуты, в его методе __init__ мы явно вызываем инициализацию каждого базового класса.

Почему нельзя использовать super()
Функция super() позволяет обращаться к методам родительского класса без прямого указания его имени. Это особенно удобно при переопределении методов, например __init__, поскольку позволяет избежать дублирования кода и упрощает сопровождение программ.

Однако при множественном наследовании использовать super() нужно осторожно. Python применяет порядок разрешения методов (MRO — Method Resolution Order), чтобы определить, в каком порядке искать методы у родительских классов. Если в такой иерархии вызвать super().__init__() только один раз, то будет выполнен __init__ только первого родителя по MRO. Остальные инициализаторы будут проигнорированы, если не вызвать их вручную.

В примере выше оба родительских класса имеют собственные __init__. Если бы мы использовали super() вместо явного вызова GreetingInformal.__init__(self), то informal_greeting не был бы создан и попытка вызвать greet_informal() привела бы к ошибке AttributeError.

Множественное наследование бывает удобно, когда:

вы хотите объединить поведение из нескольких независимых классов;
базовые классы реализуют разные аспекты (например, приветствие, логирование, сохранение данных);
необходимо повторно использовать код без создания глубокой иерархии.
Но при этом важно понимать, как работает super() и как устроен MRO, чтобы избежать неожиданных ошибок.
Теперь рассмотрим наследование с переопределением. Возьмём уже знакомый класс Car и создадим на его основе ElectricCar. Здесь уже используется одиночное наследование, но мы добавим его в этот блок как продолжение темы:

class Car:

    def __init__(self, color, consumption, tank_volume, mileage=0):
        self.color = color
        self.consumption = consumption
        self.tank_volume = tank_volume
        self.reserve = tank_volume
        self.mileage = mileage
        self.engine_on = False

    def start_engine(self):
        if not self.engine_on and self.reserve > 0:
            self.engine_on = True
            return "Двигатель запущен."
        return "Двигатель уже был запущен."

    def stop_engine(self):
        if self.engine_on:
            self.engine_on = False
            return "Двигатель остановлен."
        return "Двигатель уже был остановлен."

    def drive(self, distance):
        if not self.engine_on:
            return "Двигатель не запущен."
        if self.reserve / self.consumption * 100 < distance:
            return "Малый запас топлива."
        self.mileage += distance
        self.reserve -= distance / 100 * self.consumption
        return f"Проехали {distance} км. Остаток топлива: {self.reserve} л."

    def refuel(self):
        self.reserve = self.tank_volume

    def get_mileage(self):
        return self.mileage

    def get_reserve(self):
        return self.reserve

    def get_consumption(self):
        return self.consumption

class ElectricCar(Car):

    def __init__(self, color, consumption, bat_capacity, mileage=0):
        super().__init__(color, consumption, bat_capacity, mileage)
        self.bat_capacity = bat_capacity

    def drive(self, distance):
        if not self.engine_on:
            return "Двигатель не запущен."
        if self.reserve / self.consumption * 100 < distance:
            return "Малый запас заряда."
        self.mileage += distance
        self.reserve -= distance / 100 * self.consumption
        return f"Проехали {distance} км. Остаток заряда: {self.reserve} кВт*ч."

    def recharge(self):
        self.reserve = self.bat_capacity


electric_car = ElectricCar(color="white", consumption=15, bat_capacity=90)
print(electric_car.start_engine())
print(electric_car.drive(100))
Вывод программы:

Двигатель запущен.
Проехали 100 км. Остаток заряда: 75.0 кВт*ч.
Класс ElectricCar унаследовал поведение Car, но переопределил метод drive и добавил свой метод recharge. Благодаря этому описание класса стало более компактным и гибким.

Множественное наследование — мощный инструмент, но использовать его нужно аккуратно. В Python поиск методов и атрибутов осуществляется по порядку разрешения методов (MRO). Если в базовых классах есть совпадающие имена, приоритет получит тот класс, что указан первым. Поэтому при множественном наследовании важно чётко продумывать структуру и порядок инициализации.

Что такое специальные (магические) методы и как они используются
Давайте посмотрим, что произойдёт, если передать в функцию print() объект класса ElectricCar. Добавим в программу следующий код:

print(electric_car)

# Вывод программы:
# <__main__.ElectricCar object at 0x000002365DDD8A00>
Такой результат говорит лишь о том, что переменная electric_car — это объект класса ElectricCar, размещённый по определённому адресу в памяти. Но мы можем сделать вывод более информативным.

Когда функция print() пытается отобразить объект, она вызывает встроенную функцию str(), которая, в свою очередь, вызывает метод __str__() класса. Если определить этот метод вручную, мы можем задать, что именно будет выводиться.

Добавим метод __str__() в класс ElectricCar:

def __str__(self):
    return f"Электромобиль. " \
           f"Цвет: {self.color}. " \
           f"Пробег: {self.mileage} км. " \
           f"Остаток заряда: {self.reserve} кВт*ч."
Проверим, как теперь работает вывод:

electric_car = ElectricCar(color="белый", consumption=15, bat_capacity=90)
print(electric_car.start_engine())
print(electric_car.drive(100))
print(electric_car)

# Вывод программы:
# Двигатель запущен.
# Проехали 100 км. Остаток заряда: 75.0 кВт*ч.
# Электромобиль. Цвет: белый. Пробег: 100 км. Остаток заряда: 75.0 кВт*ч.
Магические методы (специальные методы)
Магические методы (часто называются также специальными методами) — это методы, имена которых окружены двойными подчёркиваниями, например: __init__, __str__, __add__. Такие методы вызываются автоматически при выполнении встроенных операций и функций и позволяют настроить поведение объектов под нужды вашей программы.

Этот механизм называется перегрузкой операторов (operator overloading). Вы можете определить, как именно ваш объект будет вести себя при сложении, сравнении, индексировании, отображении и других операциях.

Вот несколько примеров часто используемых магических методов:

__repr__ — вызывается функцией repr() и возвращает строку, представляющую объект в виде, пригодном для отладки и воссоздания. Также используется при отображении объектов в коллекциях.
__str__ — вызывается функцией str() и при печати объектов. Должен возвращать удобочитаемое строковое представление.
__add__ — позволяет задать поведение для оператора +.
__eq__— определяет, как объекты сравниваются на равенство (==).
__len__ — используется функцией len() для получения длины объекта.
Ниже — более подробный обзор магических методов, сгруппированных по назначению: для отображения, арифметики, сравнения, измерения длины и других операций.

Как с помощью методов __str__, __repr__, __add__ и других сделать поведение объектов более выразительным и удобным
Магические методы делают классы гибкими и выразительными. Они позволяют создавать объекты, которые ведут себя как встроенные типы данных: можно реализовать индексацию, арифметические операции, перебор, преобразование в строку и многое другое. Всё это достигается за счёт специальных методов, вызываемых автоматически при использовании операторов и встроенных функций.

Посмотрим на конкретный пример — как работают методы __add__, __radd__ и __iadd__, которые отвечают за разные варианты сложения объектов.

Пример: разница между __add__, __radd__ и __iadd__
Покажем на небольшом классе, как Python выбирает нужный метод в зависимости от контекста арифметической операции:

class A:

    def __init__(self):
        self.value = 10

    def __add__(self, other):
        return "Выполняется метод __add__."

    def __radd__(self, other):
        return "Выполняется метод __radd__."

    def __iadd__(self, other):
        self.value += other
        return self

    def __str__(self):
        return f"value: {self.value}."

a = A()
print(a + 1)
print(1 + a)
a += 1
print(a)
Вывод программы:

Выполняется метод __add__.
Выполняется метод __radd__.
value: 11.
a + 1 вызывает метод __add__;
1 + a — __radd__, так как int не умеет складываться с A;
a += 1 — __iadd__, при этом важно вернуть сам объект (self), иначе в переменной a окажется None.
Метод __repr__: представление объекта как строки кода
Для удобной отладки объектов и их отображения в списках используют метод __repr__. Он возвращает строку, которая показывает, как можно было бы воссоздать объект:

def __repr__(self):
    return f"ElectricCar('{self.color}', " \
           f"{self.consumption}, " \
           f"{self.bat_capacity}, " \
           f"{self.mileage})"
Пример использования:

electric_car = ElectricCar(color="белый", consumption=15, bat_capacity=90)
print(repr(electric_car))
electric_car_1 = ElectricCar(color="чёрный", consumption=17, bat_capacity=80)
print([electric_car, electric_car_1])

# Вывод программы

# ElectricCar('белый', 15, 90, 0)

# [ElectricCar('белый', 15, 90, 0), ElectricCar('чёрный', 17, 80, 0)]
Метод __add__: операция сложения для пользовательских объектов
С помощью метода __add__ можно задать поведение объекта при использовании оператора +. Например, сложим два электромобиля в один, суммируя их параметры:

def __add__(self, other):
    new_car = ElectricCar(self.color,
                          self.consumption + other.consumption,
                          self.bat_capacity + other.bat_capacity,
                          self.mileage + other.mileage)
    new_car.reserve = self.reserve + other.reserve
    return new_car

# Код для проверки

electric_car = ElectricCar(color="белый", consumption=15, bat_capacity=90)
electric_car_1 = ElectricCar(color="чёрный", consumption=17, bat_capacity=80)
electric_car.start_engine()
electric_car_1.start_engine()
electric_car.drive(300)
electric_car_1.drive(100)
new_electric_car = electric_car + electric_car_1
print(new_electric_car)

# Вывод программы

# Электромобиль. Цвет: белый. Пробег: 400 км. Остаток заряда: 108.0 кВт*ч

Что такое исключение и как оно влияет на выполнение программы
При выполнении заданий к предыдущим параграфам вы, скорее всего, нередко сталкивались с возникновением ошибок. В этом разделе мы разберёмся, что именно происходит при таких ошибках — и как Python позволяет их обрабатывать.

Напишем программу, которая считает обратные значения для целых чисел из заданного диапазона и выводит их в одну строку с разделителем ;. Один из возможных вариантов решения выглядит так:

print(";".join(str(1 / x) for x in range(int(input()), int(input()) + 1)))
Программа получилась очень лаконичной за счёт использования генератора внутри join. Однако если в диапазоне окажется число 0 (например, от -1 до 1), возникнет ошибка:

ZeroDivisionError: division by zero
Ошибка прерывает выполнение программы — она называется исключением. Исключения в Python — это события, которые происходят при нарушении корректного выполнения кода и останавливают его работу.

Попробуем избежать ошибки деления на ноль. Допустим, при наличии 0 в диапазоне программа просто выводит сообщение и не выполняет деление. Для этого добавим проверку:

interval = range(int(input()), int(input()) + 1)
if 0 in interval:
    print("Диапазон чисел содержит 0.")
else:
    print(";".join(str(1 / x) for x in interval))

Вступайте в сообщество хендбука
Здесь можно найти единомышленников, экспертов и просто интересных собеседников. А ещё — получить помощь или поделиться знаниями.
Теперь программа работает безопасно для диапазонов вроде от -2 до 2. Однако она по-прежнему может завершиться ошибкой, если ввести не числа:

ValueError: invalid literal for int() with base 10: 'a'
Чтобы предотвратить это, нужно проверить корректность ввода заранее. Для этого используем метод .isdigit() и учтём возможность отрицательных чисел с помощью .lstrip("-"):

start = input()
end = input()
if not (start.lstrip("-").isdigit() and end.lstrip("-").isdigit()):
    print("Необходимо ввести два числа.")
else:
    interval = range(int(start), int(end) + 1)
    if 0 in interval:
        print("Диапазон чисел содержит 0.")
    else:
        print(";".join(str(1 / x) for x in interval))
Теперь программа работает устойчиво и не вызывает исключения даже при ошибочном вводе.

В чём разница между подходами LBYL и EAFP при работе с ошибками
Подход, который был нами применён для предотвращения ошибок, называется Look Before You Leap (LBYL), или «Cначала проверь, потом действуй». В программе, реализующей такой подход, проверяются возможные условия возникновения ошибок до исполнения основного кода.

У подхода LBYL есть свои недостатки. Программу из примера стало сложнее читать из-за вложенного условного оператора. Проверка условия, что строка может быть преобразована в число, выглядит даже сложнее, чем само списочное выражение.

Кроме того, вложенный условный оператор не решает поставленную задачу, а только лишь проверяет входные данные на корректность. Легко заметить, что решение основной задачи заняло меньше времени, чем составление условий проверки корректности входных данных.

Существует другой подход для работы с ошибками: Easier to Ask Forgiveness than Permission (EAFP), или «Проще попросить прощения, чем разрешения». В этом подходе сначала исполняется код, а в случае возникновения ошибок происходит их обработка. Подход EAFP реализован в Python в виде механизма обработки исключений.

LBYL и EAFP в Python
Параметр сравнения

LBYL (Look Before You Leap)

EAFP (Easier to Ask Forgiveness than Permission)

Идея

Сначала проверяем, можно ли выполнить действие

Сначала пытаемся выполнить, а потом обрабатываем ошибки

Характер кода

Защитный, с большим числом условий

Оптимистичный, с обработкой ошибок постфактум

Минусы

Много условий, код перегружен проверками

Возможны неожиданные ошибки, если не учесть исключения

Типичный сценарий

Возможные ошибки малочисленны или
не требуют сложной проверки

Ошибки возникают на разных уровнях вложенности кода, но приводят к равноценным вариантам обработки

Как работает конструкция try–except и когда использовать else и finally
Чтобы обрабатывать ошибки в Python, используется конструкция try–except. Она позволяет «поймать» исключение, если оно произошло, и выполнить нужные действия — вместо того чтобы программа аварийно завершилась.

Базовый синтаксис
try:
    <код, который может вызвать исключение>
except <КлассИсключения_1>:
    <обработка ошибки этого типа>
except <КлассИсключения_2>:
    <обработка другого типа ошибки>
...
else:
    <выполняется, если исключений не было>
finally:
    <выполняется всегда -- и при ошибках, и без>
Почему важен порядок блоков except

Когда в блоке try возникает ошибка, Python начинает искать подходящий блок except, чтобы её обработать. Он делает это сверху вниз, по порядку.

Если первым стоит except Exception, то он перехватит практически любое исключение — почти все встроенные ошибки наследуются от Exception. В этом случае интерпретатор не дойдёт до остальных блоков, и они просто не выполнятся. Это означает, что более специфические обработчики окажутся бесполезными — их код никогда не сработает.

Пример 1. Правильный порядок

try:
    print(1 / int(input()))
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")
except Exception:
    print("Неизвестная ошибка.")
Если ввести 0, будет выведено:

Ошибка деления на ноль.
Если ввести a, будет выведено:

Невозможно преобразовать строку в число.
Если произойдёт другая ошибка — сработает except Exception.

Пример 2. Неправильный порядок

try:
    print(1 / int(input()))
except Exception:
    print("Неизвестная ошибка.")
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")
Здесь всегда сработает первый блок except Exception, и остальные никогда не будут выполнены. Поэтому при вводе и 0, и a программа выведет только:

Неизвестная ошибка.
Чтобы обработчики работали корректно, располагайте их от частных к общим — в порядке убывающей специфичности.

Блок else
else используется, если вы хотите выполнить действия только в случае, если ошибок не было. Это удобно для явного разделения логики и обработки ошибок:

try:
    print(1 / int(input()))
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")
except Exception:
    print("Неизвестная ошибка.")
else:
    print("Операция выполнена успешно.")
Ввод 5:

0.2
Операция выполнена успешно.
Ввод 0:

Ошибка деления на ноль.
Блок finally
Блок finally всегда выполняется, независимо от того, было ли исключение. Его используют для завершения операций — например, чтобы закрыть файл или освободить ресурсы:

try:
    print(1 / int(input()))
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")
except Exception:
    print("Неизвестная ошибка.")
else:
    print("Операция выполнена успешно.")
finally:
    print("Программа завершена.")
Программа завершится с финальной строкой даже в случае ошибки.

Конструкция try–except позволяет не расписывать множество условий заранее. Программа становится проще и чище, особенно по сравнению с подходом LBYL, где много вложенных проверок.

Сравним их.

Подход LBYL
start = input()
end = input()
if not (start.lstrip("-").isdigit() and end.lstrip("-").isdigit()):
    print("Введите два числа.")
else:
    interval = range(int(start), int(end) + 1)
    if 0 in interval:
        print("Диапазон чисел содержит 0.")
    else:
        print(";".join(str(1 / x) for x in interval))
Подход EAFP
Перепишем код, созданный с применением подхода LBYL, для первого примера из этого параграфа с использованием обработки исключений:

try:
    print(";".join(str(1 / x) for x in range(int(input()), int(input()) + 1)))
except ZeroDivisionError:
    print("Диапазон чисел содержит 0.")
except ValueError:
    print("Необходимо ввести два числа.")
Код с исключениями короче, проще читается, и логика задачи не утопает в проверках.

Оператор raise
Иногда нужно не просто обрабатывать исключения, но и вызывать их вручную, если данные некорректны или программа зашла в «опасное» состояние. Для этого используется оператор raise:

raise <КлассИсключения>(сообщение)
Например:

x = int(input("Введите число: "))
if x < 0:
    raise ValueError("Число должно быть положительным")
Как устроена иерархия исключений в Python и как создать собственный класс исключения
Исключения — это классы, а значит, вы можете не только использовать встроенные, но и создавать собственные. Такие классы могут наследоваться от Exception или любого другого подходящего базового исключения.

Исключения в Python являются объектами классов ошибок. Сами классы исключений организованы в иерархию, где все стандартные исключения наследуются от базового класса BaseException. Благодаря этому механизму можно группировать исключения и обрабатывать их гибко и последовательно.

В документации Python версии 3.10.8 приводится следующее дерево иерархии стандартных исключений:

BaseException
+-- SystemExit
+-- KeyboardInterrupt
+-- GeneratorExit
+-- Exception
+-- StopIteration
+-- StopAsyncIteration
+-- ArithmeticError
| +-- FloatingPointError
| +-- OverflowError
| +-- ZeroDivisionError
+-- AssertionError
+-- AttributeError
+-- BufferError
+-- EOFError
+-- ImportError
| +-- ModuleNotFoundError
+-- LookupError
| +-- IndexError
| +-- KeyError
+-- MemoryError
+-- NameError
| +-- UnboundLocalError
+-- OSError
| +-- BlockingIOError
| +-- ChildProcessError
| +-- ConnectionError
| | +-- BrokenPipeError
| | +-- ConnectionAbortedError
| | +-- ConnectionRefusedError
| | +-- ConnectionResetError
| +-- FileExistsError
| +-- FileNotFoundError
| +-- InterruptedError
| +-- IsADirectoryError
| +-- NotADirectoryError
| +-- PermissionError
| +-- ProcessLookupError
| +-- TimeoutError
+-- ReferenceError
+-- RuntimeError
| +-- NotImplementedError
| +-- RecursionError
+-- SyntaxError
| +-- IndentationError
| +-- TabError
+-- SystemError
+-- TypeError
+-- ValueError
| +-- UnicodeError
| +-- UnicodeDecodeError
| +-- UnicodeEncodeError
| +-- UnicodeTranslateError
+-- Warning
+-- DeprecationWarning
+-- PendingDeprecationWarning
+-- RuntimeWarning
+-- SyntaxWarning
+-- UserWarning
+-- FutureWarning
+-- ImportWarning
+-- UnicodeWarning
+-- BytesWarning
+-- EncodingWarning
+-- ResourceWarning

Создание собственных исключений
В Python можно создавать собственные классы исключений. Это удобно, если вы хотите точно описывать, какая именно ошибка произошла в вашей программе.

Создавать исключения следует через наследование от стандартных классов, чаще всего от Exception.

Например, создадим программу, которая складывает список целых чисел, но выбрасывает исключения, если в списке есть хотя бы одно чётное или отрицательное число.

Для этого мы создадим:

NumbersError — базовый класс для ошибок, связанных с числами;
EvenError — пользовательское исключение, которое мы будем выбрасывать, если в списке есть хотя бы одно чётное число;
NegativeError — пользовательское исключение, которое выбрасывается, если есть хотя бы одно отрицательное число.
Код:

class NumbersError(Exception):
    pass

class EvenError(NumbersError):
    pass

class NegativeError(NumbersError):
    pass

def no_even(numbers):
    if all(x % 2 != 0 for x in numbers):
        return True
    raise EvenError("В списке не должно быть чётных чисел")

def no_negative(numbers):
    if all(x >= 0 for x in numbers):
        return True
    raise NegativeError("В списке не должно быть отрицательных чисел")

def main():
    print("Введите числа в одну строку через пробел:")
    try:
        numbers = [int(x) for x in input().split()]
        if no_negative(numbers) and no_even(numbers):
            print(f"Сумма чисел равна: {sum(numbers)}.")
    except NumbersError as e:  # Обращение к исключению как к объекту
        print(f"Произошла ошибка: {e}.")
    except Exception as e:
        print(f"Произошла непредвиденная ошибка: {e}.")

if __name__ == "__main__":
    main()
Такой подход делает ошибки в вашей программе понятными и предсказуемыми, позволяет отделить их от других исключений и при необходимости обрабатывать по-разному.

Почему это удобно
Исключения стали наглядными и осмысленными: из текста ошибки понятно, что именно пошло не так.
Мы можем разделять обработку разных типов ошибок — и, если нужно, по-разному на них реагировать.
Такой подход помогает писать надёжный и предсказуемый код, особенно в сложных проектах.
Что такое модуль и как правильно его импортировать и использовать в других программах
Каждая программа на Python — это потенциальный модуль, который можно импортировать в другие файлы. Это мощный инструмент повторного использования кода.

Как Python понимает, запущен ли файл напрямую
Чтобы определить, является файл самостоятельной программой или его импортировали как модуль, используют конструкцию:

if __name__ == "__main__":
    main()
Если файл запущен напрямую, __name__ будет равен "__main__" и блок кода внутри if выполнится. Если же файл импортируют как модуль — этот код пропускается.

Почему это важно
Если вы пишете утилиту, в которой вызывается ввод/вывод или другой основной код сразу при запуске, то при импорте этого файла всё будет выполняться. Это может привести к неожиданным эффектам в другой программе.

Как правильно импортировать модули
Есть два способа импортировать модуль:

Импортировать целиком (всё пространство имён).
Импортировать отдельные объекты.
Рассмотрим каждый на примерах.

Импортируем целиком

import example_module
Теперь обращаться к функциям нужно через имя модуля:

example_module.some_function()
Импортируем отдельные объекты

from example_module import some_function, ExampleClass
Теперь вы можете использовать some_function() напрямую — но помните, что она теперь находится в пространстве имён текущей программы и имена не должны конфликтовать с другими переменными и функциями.

Пример: что может пойти не так
У нас есть файл module_hello.py с таким содержанием:

def hello(name):
    return f"Привет, {name}!"

print(hello(input("Введите своё имя: ")))
И есть вторая программа program.py, в которой мы хотим использовать функцию hello():

from module_hello import hello

print(hello(input("Добрый день. Введите имя: ")))
Если запустить program.py, вы получите два запроса имени подряд.

Потому что при импорте module_hello Python выполнил весь код в файле, включая print(hello(...)). То есть программа начала работать ещё до того, как дошла до строки print(...) в program.py.

Как это исправить
Мы можем изменить module_hello.py, чтобы код выполнялся только при прямом запуске, а не при импорте:

def hello(name):
    return f"Привет, {name}!"

if __name__ == "__main__":
    print(hello(input("Введите своё имя: ")))
Теперь при импорте ничего не будет выполнено.
Для большей читаемости основную часть программы часто оформляют как отдельную функцию main():

def hello(name):
    return f"Привет, {name}!"

def main():
    print(hello(input("Введите своё имя: ")))

if __name__ == "__main__":
    main()
А можно ли импортировать всё? Можно — но не нужно.

Вот так делать не рекомендуется:

from some_module import *
Это загрязняет пространство имён: вы не видите, откуда взялась переменная x или функция run().
Если в вашем файле уже есть объект с таким именем — он будет перезаписан.
Это затрудняет чтение и отладку кода.