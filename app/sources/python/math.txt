Какие возможности даёт модуль math для математических расчётов в Python
Python — интерпретируемый язык, а интерпретируемые языки менее производительные, чем компилируемые. При этом он повсеместно используется для задач, в которых нужна высокая производительность, — например, в машинном обучении и анализе больших данных.

Это возможно благодаря специализированным библиотекам, таким как math, numpy, pandas, которые реализованы на более низкоуровневых компилируемых языках (например, C и Fortran).

Модуль math входит в стандартную библиотеку Python и предоставляет широкий набор математических функций и констант. Он особенно полезен, когда нужно выполнять точные вычисления с числами — от элементарной арифметики до более сложных операций, включая работу с тригонометрией и логарифмами.

Функции теории чисел и представления
Эти функции пригодятся для вычислений, связанных с комбинаторикой, делимостью и произведением чисел.

Сочетания
math.comb(n, k) — вычисляет число сочетаний из n по k. Это количество способов выбрать k объектов из n, без учёта порядка и без повторений.


Вступайте в сообщество хендбука
Здесь можно найти единомышленников, экспертов и просто интересных собеседников. А ещё — получить помощь или поделиться знаниями.
Рассмотрим пример. Допустим, у нас есть 12 различных объектов — например, книг, элементов или чисел. Фраза «выбрать 3 объекта из множества из 12 элементов» означает, что из этих 12 нужно выбрать любые 3, не обращая внимания на порядок.

Для этого можно использовать math.comb:

import math

print(math.comb(12, 3))  # 220
Значит, существует 220 различных комбинаций из 3 элементов, выбранных из 12.

Факториал
math.factorial(x) — возвращает факториал числа x, то есть произведение всех целых чисел от 1 до x. Используется, например, в комбинаторике и вероятностных расчётах.

print(math.factorial(5))  # 120
Наибольший общий делитель (НОД)
math.gcd(*integers) — возвращает наибольший общий делитель (НОД) для всех аргументов. С версии Python 3.9 можно передавать более двух чисел:

print(math.gcd(120, 210, 360))  # 30
Наименьшее общее кратное (НОК)
math.lcm(*integers) — возвращает наименьшее общее кратное. Полезно при приведении дробей к общему знаменателю. Также появилась в Python 3.9.

print(math.lcm(10, 20, 30, 40))  # 120
Размещения и перестановки
math.perm(n, k=None) — возвращает количество размещений из n по k элементов (учитывается порядок). Если k не указано, считается количество перестановок — размещений всех элементов.

print(math.perm(4, 2))  # 12
print(math.perm(4))  # 24
Произведение элементов
math.prod(iterable, start=1) — перемножает все элементы в переданном итерируемом объекте (например, списке или диапазоне). Если объект пуст, возвращается значение аргумента start (по умолчанию — 1).

print(math.prod(range(10, 21)))  # 6704425728000
Степенные и логарифмические функции
Эти функции используются для работы с экспонентами, логарифмами и возведением в степень.

Экспонента
math.exp(x) — возвращает значение e^x, где e — математическая константа (приблизительно 2.71828).

print(math.exp(3.5))  # 33.11545195869231
Логарифмы
math.log(x, base) — вычисляет логарифм x по основанию base. Если основание не указано, возвращается натуральный логарифм (по основанию e).

print(math.log(10))     # 2.302585092994046
print(math.log(10, 2))  # 3.3219280948873626
Возведение в степень
math.pow(x, y) — аналог оператора **, но оба аргумента преобразуются в float, что обеспечивает точность при вещественных вычислениях.

print(math.pow(2, 10))     # 1024.0
print(math.pow(4.5, 3.7))  # 261.1477575641718
Тригонометрические функции
Функции из этой группы работают с углами и используют радианы (а не градусы) по умолчанию.

math.sin(x), math.cos(x), math.tan(x) — стандартные тригонометрические функции.
math.asin(x), math.acos(x), math.atan(x) — обратные функции.
Особые функции:

Евклидово расстояние
math.dist(p, q) — расстояние между точками p и q в пространстве. Каждая точка задаётся как итерируемый объект.

print(math.dist((0, 0, 0), (1, 1, 1)))  # 1.7320508075688772
Гипотенуза и длина вектора

math.hypot(*coordinates) — длина многомерного вектора, идущего от начала координат. Для двух координат работает как √(x² + y²).

print(math.hypot(1, 1, 1))  # 1.7320508075688772
print(math.hypot(3, 4))     # 5.0
Преобразование углов
Для работы с углами в разных системах измерения:

math.degrees(x) — переводит угол из радиан в градусы.
math.radians(x) — переводит угол из градусов в радианы.
print(round(math.degrees(math.asin(0.5)), 1))  # 30.0
print(round(math.sin(math.radians(30)), 1))   # 0.5
Гиперболические функции
Включают функции:

sinh(x), cosh(x), tanh(x) — гиперболические аналоги синуса, косинуса и тангенса;
asinh(x), acosh(x), atanh(x) — обратные к ним.
Эти функции редко используются в базовой практике, но важны в инженерных и научных вычислениях.

Специальные функции
Гамма-функция
math.gamma(x) — это обобщение факториала на вещественные числа. Для целых n выполняется gamma(n) = (n-1)!. Используется в статистике, физике и теории вероятностей.

print(math.gamma(3))    # 2.0
print(math.gamma(3.5))  # 3.323350970447842
print(math.gamma(4))    # 6.0
Математические константы
math.pi — значение числа π (3.1415926…)
math.e — основание натурального логарифма (примерно 2.71828)
Модуль math покрывает широкий спектр математических задач, связанных с отдельными числами и стандартными функциями. Однако при работе с большими объёмами данных или сложными структурами — такими как векторы, матрицы или таблицы чисел — его возможностей становится недостаточно.

В таких случаях на помощь приходит библиотека numpy, которая предназначена для эффективной работы с массивами и числовыми данными в целом. Именно она лежит в основе большинства научных и аналитических расчётов в Python.

Как устроены массивы в numpy и чем они отличаются от обычных списков
Прежде чем углубиться в работу с массивами, стоит сделать два уточнения.

Во-первых, для полного понимания материала желательно освежить знания линейной алгебры — особенно понятия матриц и операций над ними (транспонирование, умножение, обращение и др.). numpy устроена так, чтобы эффективно выполнять как базовые арифметические действия, так и более сложные линейные преобразования.

Во-вторых, библиотека numpy не входит в стандартную поставку Python. Чтобы использовать её в своём коде, сначала её необходимо установить.

Установка numpy
Установка производится через репозиторий PyPI (Python Package Index) — это коллекция внешних библиотек, доступных для Python.

В PyPI доступно более 400 000 пакетов. Для установки библиотеки потребуется подключение к интернету и выполнение следующей команды в консоли:

pip install numpy
После запуска этой команды произойдёт загрузка пакета и зависимостей, а затем установка. Если всё прошло успешно, вы увидите сообщение:

Successfully installed numpy
Для использования библиотеки её нужно импортировать. В сообществе принято импортировать numpy под псевдонимом np — это сокращает записи в коде и делает его более читаемым:

import numpy as np
Теперь можно перейти к главному объекту библиотеки — массивам.

Что такое массивы и зачем они нужны
Во многих задачах — от научных расчётов до машинного обучения — требуется обрабатывать большие объёмы числовых данных: векторы, таблицы, матрицы, временные ряды. Для этого важна скорость вычислений и эффективное использование памяти. Обычные списки Python универсальны, но не всегда подходят для таких целей: они хранят объекты произвольных типов и не оптимизированы для числовой обработки.

Массивы — это структуры данных, в которых:

все элементы имеют одинаковый тип (например, только числа с плавающей точкой);
данные хранятся компактно и последовательно в памяти;
возможна высокая производительность при выполнении операций сразу над всеми элементами.
Кроме того, массивы numpy могут быть многомерными:

одномерный массив — аналог списка;
двумерный массив — аналог таблицы или матрицы;
трёхмерный и выше — тензоры, которые применяются, например, в машинном обучении и компьютерном зрении.
Создать массив можно, например, из обычного списка с помощью функции np.array(). Обращение к элементам массива выполняется по индексам, начиная с нуля:

import numpy as np

a = np.array([1, 2, 3, 4])
b = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
print(f"a[0] = {a[0]}")
print(f"b[0] = {b[0]}")

# Вывод программы

# a[0] = 1

# b[0] = [1 2]
В этом примере массив a одномерный — у него одна ось длиной 4. Массив b двумерный — у него две оси: первая длиной 4 (строки), вторая — длиной 2 (столбцы). В документации numpy такие оси называются “axis”.

В numpy каждый массив имеет чётко определённую структуру: количество осей, их длину и тип хранимых данных. Чтобы получить эту информацию, используются атрибуты объекта ndarray — именно так называется тип, к которому принадлежат массивы в numpy.

Какие атрибуты и методы есть у объектов ndarray
Массивы в numpy — это объекты класса ndarray (англ. n-dimensional array), и каждый такой объект хранит информацию о своей структуре и содержимом. Ниже представлены наиболее важные атрибуты, которые позволяют понять, что именно находится внутри массива:

ndarray.ndim — количество осей массива (его размерность);
ndarray.shape — кортеж с количеством элементов по каждой из осей;
ndarray.size — общее число элементов в массиве;
ndarray.dtype — тип данных, хранящихся в массиве;
ndarray.itemsize — количество байт, которое занимает один элемент.
Рассмотрим пример:

import numpy as np

a = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
print(f"a.ndim = {a.ndim}, a.shape = {a.shape}, a.size = {a.size}, a.dtype = {a.dtype}")

# Вывод программы

# a.ndim = 2, a.shape = (4, 2), a.size = 8, a.dtype = int32
В этом примере массив состоит из 4 строк и 2 столбцов, всего 8 целых чисел. Каждый элемент имеет тип int32 — это целое число, занимающее 32 бита (4 байта) в памяти.

Типы данных в numpy
Типы данных в numpy тесно связаны с типами в языке C. Благодаря этому массивы можно эффективно хранить в памяти, но появляется важное ограничение: каждый тип данных имеет фиксированный диапазон допустимых значений.

Например, тип int32 может хранить только целые числа от -2 147 483 648 до 2 147 483 647. Если попытаться записать значение, выходящее за этот диапазон, произойдёт переполнение. Покажем это на примере:

import numpy as np

a = np.array([1, 2, 3], dtype="uint8")
a[0] = 256
print(a)

# Вывод программы

# [0 2 3]
Массив был создан с типом uint8 — это целые числа без знака, которые занимают 8 бит (1 байт) и могут принимать значения от 0 до 255. Попытка записать 256 приводит к переполнению: значение обнуляется (по модулю 256).

Автоматический выбор типа данных
Если не указать явно тип при создании массива, numpy попытается определить его автоматически на основе всех переданных значений. Тип будет выбран так, чтобы он подходил для хранения всех элементов.

Рассмотрим следующий пример:

import numpy as np

a = np.array([1, 2.5, 3])
print(a)
print(a.dtype)

b = np.array(['text', 1, 2.5])
print(b)
print(b.dtype)

# Вывод программы

# [1.  2.5 3. ]

# float64

# ['text' '1' '2.5']

# <U32
В массиве a есть вещественное число, поэтому все значения были приведены к типу float64. В массиве b присутствует строка, и в результате все элементы приведены к строковому типу <U32, который обозначает Unicode-строки длиной до 32 символов.

С другими встроенными типами данных numpy можно ознакомиться в официальной документации.

Как создавать, изменять и обрабатывать массивы с помощью numpy
Теперь, когда вы познакомились с тем, как устроены массивы в numpy, какие у них атрибуты и типы данных, можно перейти к практическому вопросу: как такие массивы создавать, изменять и обрабатывать.

Создание массивов
Для создания массива из нулей используется функция np.zeros(). В неё передаётся кортеж с количеством элементов по каждой оси. По умолчанию создаются массивы с типом float64, но можно указать и другой тип через аргумент dtype:

import numpy as np

a = np.zeros((4, 3))
print(a)
print()
a = np.zeros((4, 3), dtype="int32")
print(a)

# Вывод программы

# [[0. 0. 0.]

# [0. 0. 0.]

# [0. 0. 0.]

# [0. 0. 0.]]

#

# [[0 0 0]

# [0 0 0]

# [0 0 0]

# [0 0 0]]
Функция np.ones() создаёт массив аналогичного размера, но заполненный единицами:

import numpy as np

a = np.ones((4, 3))
print(a)

# Вывод

# [[1. 1. 1.]

# [1. 1. 1.]

# [1. 1. 1.]

# [1. 1. 1.]]
Для создания единичной матрицы (единицы на главной диагонали, нули в остальных ячейках) используется функция np.eye():

import numpy as np

a = np.eye(5, 5, dtype="int8")
print(a)

# Вывод

# [[1 0 0 0 0]

# [0 1 0 0 0]

# [0 0 1 0 0]

# [0 0 0 1 0]

# [0 0 0 0 1]]
Диапазоны значений
np.arange() создаёт массив, аналогичный range(), но возвращает именно массив numpy. Эта функция поддерживает как целые, так и вещественные шаги:

import numpy as np

a = np.arange(1, 10)
print(a)
print()
a = np.arange(1, 5, 0.4)
print(a)

# Вывод

# [1 2 3 4 5 6 7 8 9]

#

# [1.  1.4 1.8 2.2 2.6 3.  3.4 3.8 4.2 4.6]
np.linspace() создаёт массив из заданного числа равномерно распределённых значений на отрезке:

import numpy as np

a = np.linspace(1, 5, 10)
print(a)

# Вывод

[1. 1.44444444 1.88888889 2.33333333 2.77777778 3.22222222
 3.66666667 4.11111111 4.55555556 5.]
Изменение размерности массива
Функция reshape() позволяет задать новую форму массива. Количество элементов при этом должно сохраняться:

import numpy as np

a = np.zeros((4, 3), dtype="uint8")
print(a)
print()
a = a.reshape((2, 6))
print(a)

# Вывод

# [[0 0 0]

# [0 0 0]

# [0 0 0]

# [0 0 0]]

#

# [[0 0 0 0 0 0]

# [0 0 0 0 0 0]]
Метод resize() работает похоже, но изменяет исходный массив, а не создаёт новый:

import numpy as np

a = np.zeros((4, 3), dtype="uint8")
print(a)
print()
a.resize((2, 2, 3))
print(a)

# Вывод

# [[0 0 0]

# [0 0 0]

# [0 0 0]

# [0 0 0]]

#

# [[[0 0 0]

# [0 0 0]]

#

# [[0 0 0]

# [0 0 0]]]
Если в reshape() указать -1 по одной из осей, numpy автоматически вычислит нужное значение:

import numpy as np

a = np.zeros((4, 3), dtype="uint8")
print(a)
print()
a = a.reshape((2, 3, -1))
print(a)

# Вывод

# [[0 0 0]

# [0 0 0]

# [0 0 0]

# [0 0 0]]

#

# [[[0 0]

# [0 0]

# [0 0]]

#

# [[0 0]

# [0 0]

# [0 0]]]
Арифметика и операции над массивами
Все стандартные арифметические операции (+, -, *, /) применяются поэлементно. Размерности массивов при этом должны совпадать:

import numpy as np

a = np.array([9, 8, 7])
b = np.array([1, 2, 3])
print(a + b)
print(a - b)
print(a * b)
print(a / b)

# Вывод

# [10 10 10]

# [8 6 4]

# [9 16 21]

# [9. 4. 2.33333333]
Матричное умножение
Для умножения матриц используется оператор @ или функция np.dot():

import numpy as np

a = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])
b = np.array([[0, 0, 1],
              [0, 1, 0],
              [1, 0, 0]])
print(a @ b)

# Вывод

# [[3 2 1]

# [6 5 4]

# [9 8 7]]
Транспонирование и поворот массива
Массив можно транспонировать или повернуть. transpose() меняет оси местами, а rot90() поворачивает массив на 90 градусов (по умолчанию — против часовой стрелки):

import numpy as np

a = np.arange(1, 13).reshape(4, 3)
print(a)
print("Транспонирование")
print(a.transpose())
print("Поворот влево")
print(np.rot90(a))
print("Поворот вправо")
print(np.rot90(a, -1))
Вывод будет таким:

# [[ 1  2  3]

# [ 4  5  6]

# [ 7  8  9]

# [10 11 12]]

# Транспонирование

# [[ 1  4  7 10]

# [ 2  5  8 11]

# [ 3  6  9 12]]

# Поворот влево

# [[ 3  6  9 12]

# [ 2  5  8 11]

# [ 1  4  7 10]]

# Поворот вправо

# [[10  7  4  1]

# [11  8  5  2]

# [12  9  6  3]]
Агрегатные функции
Функции sum(), min(), max() работают по умолчанию со всем массивом:

import numpy as np

a = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])
print(a.sum())
print(a.min())
print(a.max())

# Вывод

# 45

# 1

# 9
Можно также указать ось, по которой нужно вычислять результат:

import numpy as np

a = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])
print(a.sum(axis=0))  # Сумма по столбцам
print(a.sum(axis=1))  # Сумма по строкам
print(a.min(axis=0))  # Минимум по столбцам
print(a.max(axis=1))  # Максимум по строкам

# Вывод

# [12 15 18]

# [ 6 15 24]

# [1 2 3]

# [3 6 9]
Индексация, срезы и обход массива
Массивы numpy поддерживают расширенные возможности индексирования:

import numpy as np

a = np.arange(1, 13).reshape(3, 4)
print(a)
print()
print(a[:2, 2:])     # Срез: 2 строки, последние 2 столбца
print()
print(a[:, ::2])     # Срез всех строк, каждый второй столбец

# Вывод

# [[ 1  2  3  4]

# [ 5  6  7  8]

# [ 9 10 11 12]]

#

# [[3 4]

# [7 8]]

#

# [[ 1  3]

# [ 5  7]

# [ 9 11]]
По первой оси массива можно пройтись в цикле for, как по списку:

import numpy as np

a = np.arange(1, 13).reshape(3, 4)
print(a)
for row in a:
    print(row)

# Вывод

# [[ 1  2  3  4]

# [ 5  6  7  8]

# [ 9 10 11 12]]

#

# [1 2 3 4]

# [5 6 7 8]

# [ 9 10 11 12]
Линеаризация массива
Иногда бывает нужно обработать все элементы многомерного массива как единую последовательность. Такой процесс называется линеаризацией — он превращает, например, матрицу в простой список значений. Это удобно при подсчётах, фильтрации, агрегировании.

Для последовательного доступа ко всем элементам массива без явной линеаризации можно использовать итератор flat:

import numpy as np

a = np.arange(1, 13).reshape(3, 4)
print(a)
print()
print("; ".join(str(el) for el in a.flat))

# Вывод

# [[ 1  2  3  4]

# [ 5  6  7  8]

# [ 9 10 11 12]]

#

# 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12
В чём преимущества numpy при выполнении математических операций и работе с данными
Одно из ключевых преимуществ библиотеки numpy — высокая производительность при выполнении числовых операций. Это особенно заметно при обработке больших объёмов данных.

Ниже — пример, демонстрирующий разницу в скорости между стандартным подходом на основе списков и вычислениями с использованием массивов numpy.

import numpy as np
from time import time

t = time()
print(f"Результат итератора: {sum(x **0.5 for x in range(10** 7))}.")
print(f"{time() - t} с.")
t = time()
print(f"Результат numpy: {np.sqrt(np.arange(10 ** 7)).sum()}.")
print(f"{time() - t} с.")

# Вывод программы

# Результат итератора: 21081849486.439312

# 1.7823209762573242 с

# Результат numpy: 21081849486.442448

# 0.05197310447692871 с
Вычисления с использованием numpy оказались примерно в 30 раз быстрее. Это достигается за счёт векторизации операций и низкоуровневой реализации библиотеки на языках C и Fortran.

Благодаря своей скорости и удобной работе с массивами numpy часто применяют в вычислительных библиотеках более высокого уровня. С одной из таких библиотек вы познакомитесь в следующем параграфе.